{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath.js';\nimport { Path } from '../util/graphic.js';\nimport { defaults, isArray } from 'zrender/lib/core/util.js';\nimport { getAnimationConfig } from './basicTrasition.js';\nimport { clonePath } from 'zrender/lib/tool/path.js';\n\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\n\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n\n  var off = 0; // If one has more paths than each one of many. average them.\n\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n\n  return batches;\n}\n\nvar pathDividers = {\n  clone: function (params) {\n    var ret = []; // Fitting the alpha\n\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n          fromIndividuals = _a.fromIndividuals,\n          toIndividuals = _a.toIndividuals;\n\n      var count = fromIndividuals.length;\n\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n\n  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n\n  var animateIndex = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n\n  if (isArray(elements)) {\n    var pathList_1 = [];\n\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n\n    return pathList_1;\n  }\n\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}","map":{"version":3,"names":["separateMorph","combineMorph","morphPath","isCombineMorphing","Path","defaults","isArray","getAnimationConfig","clonePath","isMultiple","elements","prepareMorphBatches","one","many","batches","batchCount","length","i","push","len","k","off","moveFrom","mid","Math","ceil","slice","pathDividers","clone","params","ret","approxOpacity","pow","path","style","opacity","count","cloned","setStyle","split","applyMorphAnimation","from","to","divideShape","seriesModel","dataIndex","animateOtherProps","updateAnimationCfg","duration","animationDelay","getModel","get","animationCfg","Object","assign","setToFinal","morphOneBatch","batch","fromIsMany","animateIndex","animateCount","forceManyOne","batchMany","batchOne","batchFrom","batchTo","individualAnimationCfg","delay","separateAnimationCfg","dividePath","individualDelay","idx","fromPath","toPath","_a","fromIndividuals","toIndividuals","morphBatches","getPathList","pathList_1","pathList","traverse","el","disableMorphing","invisible","ignore"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/animation/morphTransitionHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath.js';\nimport { Path } from '../util/graphic.js';\nimport { defaults, isArray } from 'zrender/lib/core/util.js';\nimport { getAnimationConfig } from './basicTrasition.js';\nimport { clonePath } from 'zrender/lib/tool/path.js';\n\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\n\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n\n  var off = 0; // If one has more paths than each one of many. average them.\n\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n\n  return batches;\n}\n\nvar pathDividers = {\n  clone: function (params) {\n    var ret = []; // Fitting the alpha\n\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n          fromIndividuals = _a.fromIndividuals,\n          toIndividuals = _a.toIndividuals;\n\n      var count = fromIndividuals.length;\n\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n\n  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n\n  var animateIndex = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n\n  if (isArray(elements)) {\n    var pathList_1 = [];\n\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n\n    return pathList_1;\n  }\n\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}