{"ast":null,"code":"import { cubicSubdivide } from '../core/curve.js';\nimport Path from '../graphic/Path.js';\nimport { defaults, map } from '../core/util.js';\nimport { lerp } from '../core/vector.js';\nimport { clonePath } from './path.js';\nimport Transformable from '../core/Transformable.js';\nimport { split } from './dividePath.js';\nimport { pathToBezierCurves } from './convertPath.js';\n\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n\n  var tmpSegX = [];\n  var tmpSegY = [];\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n\n    remained -= actualSubDivCount - 1;\n  }\n\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\n\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n\n  return newSubpath;\n}\n\nexport function alignBezierCurves(array1, array2) {\n  var _a;\n\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n\n  return [newArray1, newArray2];\n}\nexport function centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\n\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n\n  return bestOffset;\n}\n\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n\n  return newArr;\n}\n\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr = [];\n    var len = fromSubpathBezier.length;\n\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr[k] = newX1;\n          tmpArr[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n\n          for (var m = 0; m < tmpArr.length; m++) {\n            newToSubpathBezier[m] = tmpArr[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n\n  return result;\n}\n\nexport function isCombineMorphing(path) {\n  return path.__isCombineMorphing;\n}\nexport function isMorphing(el) {\n  return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\n\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n  var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n  var originalMethod = obj[savedMethodName] || obj[methodName];\n\n  if (!obj[savedMethodName]) {\n    obj[savedMethodName] = obj[methodName];\n  }\n\n  var replace = modifiers.replace;\n  var after = modifiers.after;\n  var before = modifiers.before;\n\n  obj[methodName] = function () {\n    var args = arguments;\n    var res;\n    before && before.apply(this, args);\n\n    if (replace) {\n      res = replace.apply(this, args);\n    } else {\n      res = originalMethod.apply(this, args);\n    }\n\n    after && after.apply(this, args);\n    return res;\n  };\n}\n\nfunction restoreMethod(obj, methodName) {\n  var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n\n  if (obj[savedMethodName]) {\n    obj[methodName] = obj[savedMethodName];\n    obj[savedMethodName] = null;\n  }\n}\n\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n  for (var i = 0; i < bezierCurves.length; i++) {\n    var subBeziers = bezierCurves[i];\n\n    for (var k = 0; k < subBeziers.length;) {\n      var x = subBeziers[k];\n      var y = subBeziers[k + 1];\n      subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n      subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n    }\n  }\n}\n\nfunction prepareMorphPath(fromPath, toPath) {\n  var fromPathProxy = fromPath.getUpdatedPathProxy();\n  var toPathProxy = toPath.getUpdatedPathProxy();\n\n  var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)),\n      fromBezierCurves = _a[0],\n      toBezierCurves = _a[1];\n\n  var fromPathTransform = fromPath.getComputedTransform();\n  var toPathTransform = toPath.getComputedTransform();\n\n  function updateIdentityTransform() {\n    this.transform = null;\n  }\n\n  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n  saveAndModifyMethod(toPath, 'updateTransform', {\n    replace: updateIdentityTransform\n  });\n  toPath.transform = null;\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  var tmpArr = [];\n  saveAndModifyMethod(toPath, 'buildPath', {\n    replace: function (path) {\n      var t = toPath.__morphT;\n      var onet = 1 - t;\n      var newCp = [];\n\n      for (var i = 0; i < morphingData.length; i++) {\n        var item = morphingData[i];\n        var from = item.from;\n        var to = item.to;\n        var angle = item.rotation * t;\n        var fromCp = item.fromCp;\n        var toCp = item.toCp;\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        lerp(newCp, fromCp, toCp, t);\n\n        for (var m = 0; m < from.length; m += 2) {\n          var x0_1 = from[m];\n          var y0_1 = from[m + 1];\n          var x1 = to[m];\n          var y1 = to[m + 1];\n          var x = x0_1 * onet + x1 * t;\n          var y = y0_1 * onet + y1 * t;\n          tmpArr[m] = x * ca - y * sa + newCp[0];\n          tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n        }\n\n        var x0 = tmpArr[0];\n        var y0 = tmpArr[1];\n        path.moveTo(x0, y0);\n\n        for (var m = 2; m < from.length;) {\n          var x1 = tmpArr[m++];\n          var y1 = tmpArr[m++];\n          var x2 = tmpArr[m++];\n          var y2 = tmpArr[m++];\n          var x3 = tmpArr[m++];\n          var y3 = tmpArr[m++];\n\n          if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n            path.lineTo(x3, y3);\n          } else {\n            path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n          }\n\n          x0 = x3;\n          y0 = y3;\n        }\n      }\n    }\n  });\n}\n\nexport function morphPath(fromPath, toPath, animationOpts) {\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n\n  var oldDone = animationOpts.done;\n  var oldDuring = animationOpts.during;\n  prepareMorphPath(fromPath, toPath);\n  toPath.__morphT = 0;\n\n  function restoreToPath() {\n    restoreMethod(toPath, 'buildPath');\n    restoreMethod(toPath, 'updateTransform');\n    toPath.__morphT = -1;\n    toPath.createPathProxy();\n    toPath.dirtyShape();\n  }\n\n  toPath.animateTo({\n    __morphT: 1\n  }, defaults({\n    during: function (p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      restoreToPath();\n      oldDone && oldDone();\n    }\n  }, animationOpts));\n  return toPath;\n}\n\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n  var bits = 16;\n  x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n  y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n  var d = 0;\n  var tmp;\n\n  for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n    var rx = 0;\n    var ry = 0;\n\n    if ((x & s) > 0) {\n      rx = 1;\n    }\n\n    if ((y & s) > 0) {\n      ry = 1;\n    }\n\n    d += s * s * (3 * rx ^ ry);\n\n    if (ry === 0) {\n      if (rx === 1) {\n        x = s - 1 - x;\n        y = s - 1 - y;\n      }\n\n      tmp = x;\n      x = y;\n      y = tmp;\n    }\n  }\n\n  return d;\n}\n\nfunction sortPaths(pathList) {\n  var xMin = Infinity;\n  var yMin = Infinity;\n  var xMax = -Infinity;\n  var yMax = -Infinity;\n  var cps = map(pathList, function (path) {\n    var rect = path.getBoundingRect();\n    var m = path.getComputedTransform();\n    var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n    var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n    xMin = Math.min(x, xMin);\n    yMin = Math.min(y, yMin);\n    xMax = Math.max(x, xMax);\n    yMax = Math.max(y, yMax);\n    return [x, y];\n  });\n  var items = map(cps, function (cp, idx) {\n    return {\n      cp: cp,\n      z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n      path: pathList[idx]\n    };\n  });\n  return items.sort(function (a, b) {\n    return a.z - b.z;\n  }).map(function (item) {\n    return item.path;\n  });\n}\n\n;\n\nfunction defaultDividePath(param) {\n  return split(param.path, param.count);\n}\n\nfunction createEmptyReturn() {\n  return {\n    fromIndividuals: [],\n    toIndividuals: [],\n    count: 0\n  };\n}\n\nexport function combineMorph(fromList, toPath, animationOpts) {\n  var fromPathList = [];\n\n  function addFromPath(fromList) {\n    for (var i = 0; i < fromList.length; i++) {\n      var from = fromList[i];\n\n      if (isCombineMorphing(from)) {\n        addFromPath(from.childrenRef());\n      } else if (from instanceof Path) {\n        fromPathList.push(from);\n      }\n    }\n  }\n\n  addFromPath(fromList);\n  var separateCount = fromPathList.length;\n\n  if (!separateCount) {\n    return createEmptyReturn();\n  }\n\n  var dividePath = animationOpts.dividePath || defaultDividePath;\n  var toSubPathList = dividePath({\n    path: toPath,\n    count: separateCount\n  });\n\n  if (toSubPathList.length !== separateCount) {\n    console.error('Invalid morphing: unmatched splitted path');\n    return createEmptyReturn();\n  }\n\n  fromPathList = sortPaths(fromPathList);\n  toSubPathList = sortPaths(toSubPathList);\n  var oldDone = animationOpts.done;\n  var oldDuring = animationOpts.during;\n  var individualDelay = animationOpts.individualDelay;\n  var identityTransform = new Transformable();\n\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromPathList[i];\n    var to = toSubPathList[i];\n    to.parent = toPath;\n    to.copyTransform(identityTransform);\n\n    if (!individualDelay) {\n      prepareMorphPath(from, to);\n    }\n  }\n\n  toPath.__isCombineMorphing = true;\n\n  toPath.childrenRef = function () {\n    return toSubPathList;\n  };\n\n  function addToSubPathListToZr(zr) {\n    for (var i = 0; i < toSubPathList.length; i++) {\n      toSubPathList[i].addSelfToZr(zr);\n    }\n  }\n\n  saveAndModifyMethod(toPath, 'addSelfToZr', {\n    after: function (zr) {\n      addToSubPathListToZr(zr);\n    }\n  });\n  saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n    after: function (zr) {\n      for (var i = 0; i < toSubPathList.length; i++) {\n        toSubPathList[i].removeSelfFromZr(zr);\n      }\n    }\n  });\n\n  function restoreToPath() {\n    toPath.__isCombineMorphing = false;\n    toPath.__morphT = -1;\n    toPath.childrenRef = null;\n    restoreMethod(toPath, 'addSelfToZr');\n    restoreMethod(toPath, 'removeSelfFromZr');\n  }\n\n  var toLen = toSubPathList.length;\n\n  if (individualDelay) {\n    var animating_1 = toLen;\n\n    var eachDone = function () {\n      animating_1--;\n\n      if (animating_1 === 0) {\n        restoreToPath();\n        oldDone && oldDone();\n      }\n    };\n\n    for (var i = 0; i < toLen; i++) {\n      var indivdualAnimationOpts = individualDelay ? defaults({\n        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n        done: eachDone\n      }, animationOpts) : animationOpts;\n      morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n    }\n  } else {\n    toPath.__morphT = 0;\n    toPath.animateTo({\n      __morphT: 1\n    }, defaults({\n      during: function (p) {\n        for (var i = 0; i < toLen; i++) {\n          var child = toSubPathList[i];\n          child.__morphT = toPath.__morphT;\n          child.dirtyShape();\n        }\n\n        oldDuring && oldDuring(p);\n      },\n      done: function () {\n        restoreToPath();\n\n        for (var i = 0; i < fromList.length; i++) {\n          restoreMethod(fromList[i], 'updateTransform');\n        }\n\n        oldDone && oldDone();\n      }\n    }, animationOpts));\n  }\n\n  if (toPath.__zr) {\n    addToSubPathListToZr(toPath.__zr);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toSubPathList,\n    count: toLen\n  };\n}\nexport function separateMorph(fromPath, toPathList, animationOpts) {\n  var toLen = toPathList.length;\n  var fromPathList = [];\n  var dividePath = animationOpts.dividePath || defaultDividePath;\n\n  function addFromPath(fromList) {\n    for (var i = 0; i < fromList.length; i++) {\n      var from = fromList[i];\n\n      if (isCombineMorphing(from)) {\n        addFromPath(from.childrenRef());\n      } else if (from instanceof Path) {\n        fromPathList.push(from);\n      }\n    }\n  }\n\n  if (isCombineMorphing(fromPath)) {\n    addFromPath(fromPath.childrenRef());\n    var fromLen = fromPathList.length;\n\n    if (fromLen < toLen) {\n      var k = 0;\n\n      for (var i = fromLen; i < toLen; i++) {\n        fromPathList.push(clonePath(fromPathList[k++ % fromLen]));\n      }\n    }\n\n    fromPathList.length = toLen;\n  } else {\n    fromPathList = dividePath({\n      path: fromPath,\n      count: toLen\n    });\n    var fromPathTransform = fromPath.getComputedTransform();\n\n    for (var i = 0; i < fromPathList.length; i++) {\n      fromPathList[i].setLocalTransform(fromPathTransform);\n    }\n\n    if (fromPathList.length !== toLen) {\n      console.error('Invalid morphing: unmatched splitted path');\n      return createEmptyReturn();\n    }\n  }\n\n  fromPathList = sortPaths(fromPathList);\n  toPathList = sortPaths(toPathList);\n  var individualDelay = animationOpts.individualDelay;\n\n  for (var i = 0; i < toLen; i++) {\n    var indivdualAnimationOpts = individualDelay ? defaults({\n      delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n    }, animationOpts) : animationOpts;\n    morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathList.length\n  };\n}\nexport { split as defaultDividePath };","map":{"version":3,"names":["cubicSubdivide","Path","defaults","map","lerp","clonePath","Transformable","split","pathToBezierCurves","alignSubpath","subpath1","subpath2","len1","length","len2","tmpSegX","tmpSegY","shorterPath","shorterLen","Math","min","diff","abs","shorterBezierCount","eachCurveSubDivCount","ceil","newSubpath","remained","i","x0","y0","x1","y1","x2","y2","x3","y3","push","actualSubDivCount","k","p","createSubpath","lastSubpathSubpath","otherSubpath","len","lastX","lastY","alignBezierCurves","array1","array2","_a","lastSubpath1","lastSubpath2","newArray1","newArray2","max","newSubpath1","newSubpath2","centroid","array","signedArea","cx","cy","j","a","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","idx","dx","dy","reverse","newArr","findBestMorphingRotation","fromArr","toArr","searchAngleIteration","searchAngleRange","result","fromNeedsReverse","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr","step","angle","sa","sin","ca","cos","newX1","newY1","m","i_1","from","to","rotation","isCombineMorphing","path","__isCombineMorphing","isMorphing","el","__morphT","SAVED_METHOD_PREFIX","saveAndModifyMethod","obj","methodName","modifiers","savedMethodName","originalMethod","replace","after","before","args","arguments","res","apply","restoreMethod","applyTransformOnBeziers","bezierCurves","mm","subBeziers","x","y","prepareMorphPath","fromPath","toPath","fromPathProxy","getUpdatedPathProxy","toPathProxy","fromBezierCurves","toBezierCurves","fromPathTransform","getComputedTransform","toPathTransform","updateIdentityTransform","transform","morphingData","PI","t","onet","newCp","item","x0_1","y0_1","moveTo","lineTo","bezierCurveTo","morphPath","animationOpts","oldDone","done","oldDuring","during","restoreToPath","createPathProxy","dirtyShape","animateTo","hilbert","minX","minY","maxX","maxY","bits","round","d","tmp","s","rx","ry","sortPaths","pathList","xMin","yMin","xMax","yMax","cps","rect","getBoundingRect","width","height","items","cp","z","sort","b","defaultDividePath","param","count","createEmptyReturn","fromIndividuals","toIndividuals","combineMorph","fromList","fromPathList","addFromPath","childrenRef","separateCount","dividePath","toSubPathList","console","error","individualDelay","identityTransform","parent","copyTransform","addToSubPathListToZr","zr","addSelfToZr","removeSelfFromZr","toLen","animating_1","eachDone","indivdualAnimationOpts","delay","child","__zr","separateMorph","toPathList","fromLen","setLocalTransform"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/zrender/lib/tool/morphPath.js"],"sourcesContent":["import { cubicSubdivide } from '../core/curve.js';\nimport Path from '../graphic/Path.js';\nimport { defaults, map } from '../core/util.js';\nimport { lerp } from '../core/vector.js';\nimport { clonePath } from './path.js';\nimport Transformable from '../core/Transformable.js';\nimport { split } from './dividePath.js';\nimport { pathToBezierCurves } from './convertPath.js';\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr[k] = newX1;\n                    tmpArr[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr.length; m++) {\n                        newToSubpathBezier[m] = tmpArr[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function isCombineMorphing(path) {\n    return path.__isCombineMorphing;\n}\nexport function isMorphing(el) {\n    return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    var originalMethod = obj[savedMethodName] || obj[methodName];\n    if (!obj[savedMethodName]) {\n        obj[savedMethodName] = obj[methodName];\n    }\n    var replace = modifiers.replace;\n    var after = modifiers.after;\n    var before = modifiers.before;\n    obj[methodName] = function () {\n        var args = arguments;\n        var res;\n        before && before.apply(this, args);\n        if (replace) {\n            res = replace.apply(this, args);\n        }\n        else {\n            res = originalMethod.apply(this, args);\n        }\n        after && after.apply(this, args);\n        return res;\n    };\n}\nfunction restoreMethod(obj, methodName) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    if (obj[savedMethodName]) {\n        obj[methodName] = obj[savedMethodName];\n        obj[savedMethodName] = null;\n    }\n}\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n    for (var i = 0; i < bezierCurves.length; i++) {\n        var subBeziers = bezierCurves[i];\n        for (var k = 0; k < subBeziers.length;) {\n            var x = subBeziers[k];\n            var y = subBeziers[k + 1];\n            subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n            subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n        }\n    }\n}\nfunction prepareMorphPath(fromPath, toPath) {\n    var fromPathProxy = fromPath.getUpdatedPathProxy();\n    var toPathProxy = toPath.getUpdatedPathProxy();\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var fromPathTransform = fromPath.getComputedTransform();\n    var toPathTransform = toPath.getComputedTransform();\n    function updateIdentityTransform() {\n        this.transform = null;\n    }\n    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n    saveAndModifyMethod(toPath, 'updateTransform', { replace: updateIdentityTransform });\n    toPath.transform = null;\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    var tmpArr = [];\n    saveAndModifyMethod(toPath, 'buildPath', { replace: function (path) {\n            var t = toPath.__morphT;\n            var onet = 1 - t;\n            var newCp = [];\n            for (var i = 0; i < morphingData.length; i++) {\n                var item = morphingData[i];\n                var from = item.from;\n                var to = item.to;\n                var angle = item.rotation * t;\n                var fromCp = item.fromCp;\n                var toCp = item.toCp;\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                lerp(newCp, fromCp, toCp, t);\n                for (var m = 0; m < from.length; m += 2) {\n                    var x0_1 = from[m];\n                    var y0_1 = from[m + 1];\n                    var x1 = to[m];\n                    var y1 = to[m + 1];\n                    var x = x0_1 * onet + x1 * t;\n                    var y = y0_1 * onet + y1 * t;\n                    tmpArr[m] = (x * ca - y * sa) + newCp[0];\n                    tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n                }\n                var x0 = tmpArr[0];\n                var y0 = tmpArr[1];\n                path.moveTo(x0, y0);\n                for (var m = 2; m < from.length;) {\n                    var x1 = tmpArr[m++];\n                    var y1 = tmpArr[m++];\n                    var x2 = tmpArr[m++];\n                    var y2 = tmpArr[m++];\n                    var x3 = tmpArr[m++];\n                    var y3 = tmpArr[m++];\n                    if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n                        path.lineTo(x3, y3);\n                    }\n                    else {\n                        path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                    }\n                    x0 = x3;\n                    y0 = y3;\n                }\n            }\n        } });\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    prepareMorphPath(fromPath, toPath);\n    toPath.__morphT = 0;\n    function restoreToPath() {\n        restoreMethod(toPath, 'buildPath');\n        restoreMethod(toPath, 'updateTransform');\n        toPath.__morphT = -1;\n        toPath.createPathProxy();\n        toPath.dirtyShape();\n    }\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreToPath();\n            oldDone && oldDone();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n    var bits = 16;\n    x = (maxX === minX) ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n    y = (maxY === minY) ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n    var d = 0;\n    var tmp;\n    for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n        var rx = 0;\n        var ry = 0;\n        if ((x & s) > 0) {\n            rx = 1;\n        }\n        if ((y & s) > 0) {\n            ry = 1;\n        }\n        d += s * s * ((3 * rx) ^ ry);\n        if (ry === 0) {\n            if (rx === 1) {\n                x = s - 1 - x;\n                y = s - 1 - y;\n            }\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n    }\n    return d;\n}\nfunction sortPaths(pathList) {\n    var xMin = Infinity;\n    var yMin = Infinity;\n    var xMax = -Infinity;\n    var yMax = -Infinity;\n    var cps = map(pathList, function (path) {\n        var rect = path.getBoundingRect();\n        var m = path.getComputedTransform();\n        var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n        var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n        xMin = Math.min(x, xMin);\n        yMin = Math.min(y, yMin);\n        xMax = Math.max(x, xMax);\n        yMax = Math.max(y, yMax);\n        return [x, y];\n    });\n    var items = map(cps, function (cp, idx) {\n        return {\n            cp: cp,\n            z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n            path: pathList[idx]\n        };\n    });\n    return items.sort(function (a, b) { return a.z - b.z; }).map(function (item) { return item.path; });\n}\n;\nfunction defaultDividePath(param) {\n    return split(param.path, param.count);\n}\nfunction createEmptyReturn() {\n    return {\n        fromIndividuals: [],\n        toIndividuals: [],\n        count: 0\n    };\n}\nexport function combineMorph(fromList, toPath, animationOpts) {\n    var fromPathList = [];\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    addFromPath(fromList);\n    var separateCount = fromPathList.length;\n    if (!separateCount) {\n        return createEmptyReturn();\n    }\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    var toSubPathList = dividePath({\n        path: toPath, count: separateCount\n    });\n    if (toSubPathList.length !== separateCount) {\n        console.error('Invalid morphing: unmatched splitted path');\n        return createEmptyReturn();\n    }\n    fromPathList = sortPaths(fromPathList);\n    toSubPathList = sortPaths(toSubPathList);\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    var individualDelay = animationOpts.individualDelay;\n    var identityTransform = new Transformable();\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromPathList[i];\n        var to = toSubPathList[i];\n        to.parent = toPath;\n        to.copyTransform(identityTransform);\n        if (!individualDelay) {\n            prepareMorphPath(from, to);\n        }\n    }\n    toPath.__isCombineMorphing = true;\n    toPath.childrenRef = function () {\n        return toSubPathList;\n    };\n    function addToSubPathListToZr(zr) {\n        for (var i = 0; i < toSubPathList.length; i++) {\n            toSubPathList[i].addSelfToZr(zr);\n        }\n    }\n    saveAndModifyMethod(toPath, 'addSelfToZr', {\n        after: function (zr) {\n            addToSubPathListToZr(zr);\n        }\n    });\n    saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n        after: function (zr) {\n            for (var i = 0; i < toSubPathList.length; i++) {\n                toSubPathList[i].removeSelfFromZr(zr);\n            }\n        }\n    });\n    function restoreToPath() {\n        toPath.__isCombineMorphing = false;\n        toPath.__morphT = -1;\n        toPath.childrenRef = null;\n        restoreMethod(toPath, 'addSelfToZr');\n        restoreMethod(toPath, 'removeSelfFromZr');\n    }\n    var toLen = toSubPathList.length;\n    if (individualDelay) {\n        var animating_1 = toLen;\n        var eachDone = function () {\n            animating_1--;\n            if (animating_1 === 0) {\n                restoreToPath();\n                oldDone && oldDone();\n            }\n        };\n        for (var i = 0; i < toLen; i++) {\n            var indivdualAnimationOpts = individualDelay ? defaults({\n                delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n                done: eachDone\n            }, animationOpts) : animationOpts;\n            morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n        }\n    }\n    else {\n        toPath.__morphT = 0;\n        toPath.animateTo({\n            __morphT: 1\n        }, defaults({\n            during: function (p) {\n                for (var i = 0; i < toLen; i++) {\n                    var child = toSubPathList[i];\n                    child.__morphT = toPath.__morphT;\n                    child.dirtyShape();\n                }\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                restoreToPath();\n                for (var i = 0; i < fromList.length; i++) {\n                    restoreMethod(fromList[i], 'updateTransform');\n                }\n                oldDone && oldDone();\n            }\n        }, animationOpts));\n    }\n    if (toPath.__zr) {\n        addToSubPathListToZr(toPath.__zr);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toSubPathList,\n        count: toLen\n    };\n}\nexport function separateMorph(fromPath, toPathList, animationOpts) {\n    var toLen = toPathList.length;\n    var fromPathList = [];\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    if (isCombineMorphing(fromPath)) {\n        addFromPath(fromPath.childrenRef());\n        var fromLen = fromPathList.length;\n        if (fromLen < toLen) {\n            var k = 0;\n            for (var i = fromLen; i < toLen; i++) {\n                fromPathList.push(clonePath(fromPathList[k++ % fromLen]));\n            }\n        }\n        fromPathList.length = toLen;\n    }\n    else {\n        fromPathList = dividePath({ path: fromPath, count: toLen });\n        var fromPathTransform = fromPath.getComputedTransform();\n        for (var i = 0; i < fromPathList.length; i++) {\n            fromPathList[i].setLocalTransform(fromPathTransform);\n        }\n        if (fromPathList.length !== toLen) {\n            console.error('Invalid morphing: unmatched splitted path');\n            return createEmptyReturn();\n        }\n    }\n    fromPathList = sortPaths(fromPathList);\n    toPathList = sortPaths(toPathList);\n    var individualDelay = animationOpts.individualDelay;\n    for (var i = 0; i < toLen; i++) {\n        var indivdualAnimationOpts = individualDelay ? defaults({\n            delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n        }, animationOpts) : animationOpts;\n        morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathList.length\n    };\n}\nexport { split as defaultDividePath };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}