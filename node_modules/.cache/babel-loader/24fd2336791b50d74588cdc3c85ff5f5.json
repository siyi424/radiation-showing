{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as numberUtil from '../util/number.js';\nimport * as formatUtil from '../util/format.js';\nimport Scale from './Scale.js';\nimport * as helper from './helper.js';\nvar roundNumber = numberUtil.round;\n\nvar IntervalScale =\n/** @class */\nfunction (_super) {\n  __extends(IntervalScale, _super);\n\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'interval'; // Step is calculated in adjustExtent.\n\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n\n  IntervalScale.prototype.parse = function (val) {\n    return val;\n  };\n\n  IntervalScale.prototype.contain = function (val) {\n    return helper.contain(val, this._extent);\n  };\n\n  IntervalScale.prototype.normalize = function (val) {\n    return helper.normalize(val, this._extent);\n  };\n\n  IntervalScale.prototype.scale = function (val) {\n    return helper.scale(val, this._extent);\n  };\n\n  IntervalScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent; // start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  };\n\n  IntervalScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    this.setExtent(extent[0], extent[1]);\n  };\n\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  };\n  /**\n   * @param expandToNicedExtent Whether expand the ticks to niced extent.\n   */\n\n\n  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = []; // If interval is 0, return [];\n\n    if (!interval) {\n      return ticks;\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      }); // Avoid rounding error\n\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1].value) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    } // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n\n    return ticks;\n  };\n\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  };\n  /**\n   * @param opt.precision If 'auto', use nice presision.\n   * @param opt.pad returns 1.50 but not 1.5 if precision is 2.\n   */\n\n\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecision(data.value) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    var dataNum = roundNumber(data.value, precision, true);\n    return formatUtil.addCommas(dataNum);\n  };\n  /**\n   * @param splitNumber By default `5`.\n   */\n\n\n  IntervalScale.prototype.calcNiceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n\n  IntervalScale.prototype.calcNiceExtent = function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // let extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  };\n\n  IntervalScale.prototype.setNiceExtent = function (min, max) {\n    this._niceExtent = [min, max];\n  };\n\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(Scale);\n\nScale.registerClass(IntervalScale);\nexport default IntervalScale;","map":{"version":3,"names":["__extends","numberUtil","formatUtil","Scale","helper","roundNumber","round","IntervalScale","_super","_this","apply","arguments","type","_interval","_intervalPrecision","prototype","parse","val","contain","_extent","normalize","scale","setExtent","start","end","thisExtent","isNaN","parseFloat","unionExtent","other","extent","getInterval","setInterval","interval","_niceExtent","slice","getIntervalPrecision","getTicks","expandToNicedExtent","niceTickExtent","intervalPrecision","ticks","safeLimit","push","value","tick","length","lastNiceTick","getMinorTicks","splitNumber","minorTicks","getExtent","i","nextTick","prevTick","count","minorTicksGroup","minorInterval","minorTick","getLabel","data","opt","precision","getPrecision","dataNum","addCommas","calcNiceTicks","minInterval","maxInterval","span","isFinite","reverse","result","intervalScaleNiceTicks","calcNiceExtent","expandSize","fixMax","fixMin","Math","floor","ceil","setNiceExtent","min","max","registerClass"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/scale/Interval.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as numberUtil from '../util/number.js';\nimport * as formatUtil from '../util/format.js';\nimport Scale from './Scale.js';\nimport * as helper from './helper.js';\nvar roundNumber = numberUtil.round;\n\nvar IntervalScale =\n/** @class */\nfunction (_super) {\n  __extends(IntervalScale, _super);\n\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'interval'; // Step is calculated in adjustExtent.\n\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n\n  IntervalScale.prototype.parse = function (val) {\n    return val;\n  };\n\n  IntervalScale.prototype.contain = function (val) {\n    return helper.contain(val, this._extent);\n  };\n\n  IntervalScale.prototype.normalize = function (val) {\n    return helper.normalize(val, this._extent);\n  };\n\n  IntervalScale.prototype.scale = function (val) {\n    return helper.scale(val, this._extent);\n  };\n\n  IntervalScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent; // start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  };\n\n  IntervalScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    this.setExtent(extent[0], extent[1]);\n  };\n\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  };\n  /**\n   * @param expandToNicedExtent Whether expand the ticks to niced extent.\n   */\n\n\n  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = []; // If interval is 0, return [];\n\n    if (!interval) {\n      return ticks;\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      }); // Avoid rounding error\n\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1].value) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    } // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n\n    return ticks;\n  };\n\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  };\n  /**\n   * @param opt.precision If 'auto', use nice presision.\n   * @param opt.pad returns 1.50 but not 1.5 if precision is 2.\n   */\n\n\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecision(data.value) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    var dataNum = roundNumber(data.value, precision, true);\n    return formatUtil.addCommas(dataNum);\n  };\n  /**\n   * @param splitNumber By default `5`.\n   */\n\n\n  IntervalScale.prototype.calcNiceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n\n  IntervalScale.prototype.calcNiceExtent = function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // let extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  };\n\n  IntervalScale.prototype.setNiceExtent = function (min, max) {\n    this._niceExtent = [min, max];\n  };\n\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(Scale);\n\nScale.registerClass(IntervalScale);\nexport default IntervalScale;"],"mappings":"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"},"metadata":{},"sourceType":"module"}