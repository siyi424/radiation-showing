{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as layoutUtil from '../../util/layout.js';\nimport LegendView from './LegendView.js';\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\n\nvar ScrollableLegendView =\n/** @class */\nfunction (_super) {\n  __extends(ScrollableLegendView, _super);\n\n  function ScrollableLegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = ScrollableLegendView.type;\n    _this.newlineDisabled = true;\n    _this._currentIndex = 0;\n    return _this;\n  }\n\n  ScrollableLegendView.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n\n    this.group.add(this._controllerGroup = new Group());\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.resetInner = function () {\n    _super.prototype.resetInner.call(this);\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var self = this; // Render content items.\n\n    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    var pageIconSizeArr = zrUtil.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        // Placeholder to calculate a proper layout.\n        text: 'xx/xx',\n        fill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        verticalAlign: 'middle',\n        align: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSizeArr[0] / 2,\n        y: -pageIconSizeArr[1] / 2,\n        width: pageIconSizeArr[0],\n        height: pageIconSizeArr[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      selectorGroup.markRedraw();\n    }\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]\n\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup[xy];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n      }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.setPosition(contentPos);\n    containerGroup.setPosition(containerPos);\n    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      x: pageInfo.contentPosition[0],\n      y: pageInfo.contentPosition[1]\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : null);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  };\n\n  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var key = name + 'DataIndex';\n      var canJump = pageInfo[key] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n      current: current,\n      total: total\n    }));\n  };\n  /**\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n\n\n  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: [contentGroup.x, contentGroup.y],\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el[xy];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  };\n\n  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  };\n\n  ScrollableLegendView.type = 'legend.scroll';\n  return ScrollableLegendView;\n}(LegendView);\n\nexport default ScrollableLegendView;","map":{"version":3,"names":["__extends","zrUtil","graphic","layoutUtil","LegendView","Group","WH","XY","ScrollableLegendView","_super","_this","apply","arguments","type","newlineDisabled","_currentIndex","prototype","init","call","group","add","_containerGroup","getContentGroup","_controllerGroup","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","selector","orient","selectorPosition","self","controllerGroup","pageIconSize","get","pageIconSizeArr","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","text","fill","getTextColor","font","getFont","verticalAlign","align","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","isFirstRender","selectorGroup","getSelectorGroup","orientIdx","index","wh","xy","hw","yx","box","selectorButtonGap","selectorRect","getBoundingRect","selectorPos","processMaxSize","clone","mainRect","_layoutContentAndController","offset","Math","max","min","markRedraw","contentGroup","containerGroup","contentRect","controllerRect","showController","_showController","contentPos","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","setPosition","clipShape","setClipPath","Rect","shape","eachChild","child","attr","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","key","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","containerRectSize","targetItemIndex","_findTargetItemIndex","children","targetItem","itemCount","length","pCount","result","pagePrevDataIndex","pageNextDataIndex","targetItemInfo","getItemInfo","s","i","winStartItemInfo","winEndItemInfo","currItemInfo","e","intersect","el","itemRect","start","__legendDataIndex","itemInfo","winStart","targetDataIndex","defaultIndex","idx","legendDataIdx"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as layoutUtil from '../../util/layout.js';\nimport LegendView from './LegendView.js';\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\n\nvar ScrollableLegendView =\n/** @class */\nfunction (_super) {\n  __extends(ScrollableLegendView, _super);\n\n  function ScrollableLegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = ScrollableLegendView.type;\n    _this.newlineDisabled = true;\n    _this._currentIndex = 0;\n    return _this;\n  }\n\n  ScrollableLegendView.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n\n    this.group.add(this._controllerGroup = new Group());\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.resetInner = function () {\n    _super.prototype.resetInner.call(this);\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var self = this; // Render content items.\n\n    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    var pageIconSizeArr = zrUtil.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        // Placeholder to calculate a proper layout.\n        text: 'xx/xx',\n        fill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        verticalAlign: 'middle',\n        align: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSizeArr[0] / 2,\n        y: -pageIconSizeArr[1] / 2,\n        width: pageIconSizeArr[0],\n        height: pageIconSizeArr[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      selectorGroup.markRedraw();\n    }\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]\n\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup[xy];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.setPosition(contentPos);\n    containerGroup.setPosition(containerPos);\n    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      x: pageInfo.contentPosition[0],\n      y: pageInfo.contentPosition[1]\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : null);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  };\n\n  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var key = name + 'DataIndex';\n      var canJump = pageInfo[key] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n      current: current,\n      total: total\n    }));\n  };\n  /**\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n\n\n  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: [contentGroup.x, contentGroup.y],\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el[xy];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  };\n\n  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  };\n\n  ScrollableLegendView.type = 'legend.scroll';\n  return ScrollableLegendView;\n}(LegendView);\n\nexport default ScrollableLegendView;"],"mappings":"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"},"metadata":{},"sourceType":"module"}