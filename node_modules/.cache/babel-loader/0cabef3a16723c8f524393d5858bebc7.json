{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getPrecisionSafe, round } from '../util/number.js';\nimport IntervalScale from '../scale/Interval.js';\nimport { getScaleExtent } from './axisHelper.js';\nimport { warn } from '../util/log.js';\nimport { increaseInterval, isValueNice } from '../scale/helper.js';\nvar mathLog = Math.log;\nexport function alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = IntervalScale.prototype; // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = getScaleExtent(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n\n  if (scale.type === 'log') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale); // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'\n\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber; // User set min, expand extent on the other side\n\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = increaseInterval(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = increaseInterval(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = increaseInterval(interval);\n    }\n\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = round(max - range); // Not change the result that crossing zero.\n\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = round(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -round(range);\n    }\n  } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n\n\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval; // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    var ticks = intervalScaleProto.getTicks.call(scale);\n\n    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {\n      warn( // eslint-disable-next-line\n      \"The ticks may be not readable when set min: \" + axisModel.get('min') + \", max: \" + axisModel.get('max') + \" and alignTicks: true\");\n    }\n  }\n}","map":{"version":3,"names":["getPrecisionSafe","round","IntervalScale","getScaleExtent","warn","increaseInterval","isValueNice","mathLog","Math","log","alignScaleTicks","scale","axisModel","alignToScale","intervalScaleProto","prototype","alignToTicks","getTicks","call","alignToNicedTicks","alignToSplitNumber","length","alignToInterval","getInterval","scaleExtent","rawExtent","extent","isMinFixed","fixMin","isMaxFixed","fixMax","type","logBase","base","setExtent","calcNiceExtent","splitNumber","getExtent","interval","min","max","isFinite","nicedSplitNumber","range","ceil","t0","value","t1","setInterval","setNiceExtent","process","env","NODE_ENV","ticks","get"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/coord/axisAlignTicks.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getPrecisionSafe, round } from '../util/number.js';\nimport IntervalScale from '../scale/Interval.js';\nimport { getScaleExtent } from './axisHelper.js';\nimport { warn } from '../util/log.js';\nimport { increaseInterval, isValueNice } from '../scale/helper.js';\nvar mathLog = Math.log;\nexport function alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = IntervalScale.prototype; // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = getScaleExtent(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n\n  if (scale.type === 'log') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale); // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'\n\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber; // User set min, expand extent on the other side\n\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = increaseInterval(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = increaseInterval(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = increaseInterval(interval);\n    }\n\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = round(max - range); // Not change the result that crossing zero.\n\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = round(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -round(range);\n    }\n  } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n\n\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval; // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    var ticks = intervalScaleProto.getTicks.call(scale);\n\n    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {\n      warn( // eslint-disable-next-line\n      \"The ticks may be not readable when set min: \" + axisModel.get('min') + \", max: \" + axisModel.get('max') + \" and alignTicks: true\");\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}