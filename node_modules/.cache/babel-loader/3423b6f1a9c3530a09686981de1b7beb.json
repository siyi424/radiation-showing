{"ast":null,"code":"import { fromPoints } from '../core/bbox.js';\nimport BoundingRect from '../core/BoundingRect.js';\nimport Point from '../core/Point.js';\nimport { map } from '../core/util.js';\nimport Polygon from '../graphic/shape/Polygon.js';\nimport Rect from '../graphic/shape/Rect.js';\nimport Sector from '../graphic/shape/Sector.js';\nimport { pathToPolygons } from './convertPath.js';\nimport { clonePath } from './path.js';\n\nfunction getDividingGrids(dimSize, rowDim, count) {\n  var rowSize = dimSize[rowDim];\n  var columnSize = dimSize[1 - rowDim];\n  var ratio = Math.abs(rowSize / columnSize);\n  var rowCount = Math.ceil(Math.sqrt(ratio * count));\n  var columnCount = Math.floor(count / rowCount);\n\n  if (columnCount === 0) {\n    columnCount = 1;\n    rowCount = count;\n  }\n\n  var grids = [];\n\n  for (var i = 0; i < rowCount; i++) {\n    grids.push(columnCount);\n  }\n\n  var currentCount = rowCount * columnCount;\n  var remained = count - currentCount;\n\n  if (remained > 0) {\n    for (var i = 0; i < remained; i++) {\n      grids[i % rowCount] += 1;\n    }\n  }\n\n  return grids;\n}\n\nfunction divideSector(sectorShape, count, outShapes) {\n  var r0 = sectorShape.r0;\n  var r = sectorShape.r;\n  var startAngle = sectorShape.startAngle;\n  var endAngle = sectorShape.endAngle;\n  var angle = Math.abs(endAngle - startAngle);\n  var arcLen = angle * r;\n  var deltaR = r - r0;\n  var isAngleRow = arcLen > Math.abs(deltaR);\n  var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n  var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n\n  for (var row = 0; row < grids.length; row++) {\n    var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n\n    for (var column = 0; column < grids[row]; column++) {\n      var newShape = {};\n\n      if (isAngleRow) {\n        newShape.startAngle = startAngle + rowSize * row;\n        newShape.endAngle = startAngle + rowSize * (row + 1);\n        newShape.r0 = r0 + columnSize * column;\n        newShape.r = r0 + columnSize * (column + 1);\n      } else {\n        newShape.startAngle = startAngle + columnSize * column;\n        newShape.endAngle = startAngle + columnSize * (column + 1);\n        newShape.r0 = r0 + rowSize * row;\n        newShape.r = r0 + rowSize * (row + 1);\n      }\n\n      newShape.clockwise = sectorShape.clockwise;\n      newShape.cx = sectorShape.cx;\n      newShape.cy = sectorShape.cy;\n      outShapes.push(newShape);\n    }\n  }\n}\n\nfunction divideRect(rectShape, count, outShapes) {\n  var width = rectShape.width;\n  var height = rectShape.height;\n  var isHorizontalRow = width > height;\n  var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n  var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n  var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n  var rowDim = isHorizontalRow ? 'x' : 'y';\n  var columnDim = isHorizontalRow ? 'y' : 'x';\n  var rowSize = rectShape[rowSizeDim] / grids.length;\n\n  for (var row = 0; row < grids.length; row++) {\n    var columnSize = rectShape[columnSizeDim] / grids[row];\n\n    for (var column = 0; column < grids[row]; column++) {\n      var newShape = {};\n      newShape[rowDim] = row * rowSize;\n      newShape[columnDim] = column * columnSize;\n      newShape[rowSizeDim] = rowSize;\n      newShape[columnSizeDim] = columnSize;\n      newShape.x += rectShape.x;\n      newShape.y += rectShape.y;\n      outShapes.push(newShape);\n    }\n  }\n}\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\n\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y;\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n  if (Math.abs(nmCrossProduct) < 1e-6) {\n    return null;\n  }\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n  if (p < 0 || p > 1) {\n    return null;\n  }\n\n  return new Point(p * mx + a1x, p * my + a1y);\n}\n\nfunction projPtOnLine(pt, lineA, lineB) {\n  var dir = new Point();\n  Point.sub(dir, lineB, lineA);\n  dir.normalize();\n  var dir2 = new Point();\n  Point.sub(dir2, pt, lineA);\n  var len = dir2.dot(dir);\n  return len;\n}\n\nfunction addToPoly(poly, pt) {\n  var last = poly[poly.length - 1];\n\n  if (last && last[0] === pt[0] && last[1] === pt[1]) {\n    return;\n  }\n\n  poly.push(pt);\n}\n\nfunction splitPolygonByLine(points, lineA, lineB) {\n  var len = points.length;\n  var intersections = [];\n\n  for (var i = 0; i < len; i++) {\n    var p0 = points[i];\n    var p1 = points[(i + 1) % len];\n    var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n\n    if (intersectionPt) {\n      intersections.push({\n        projPt: projPtOnLine(intersectionPt, lineA, lineB),\n        pt: intersectionPt,\n        idx: i\n      });\n    }\n  }\n\n  if (intersections.length < 2) {\n    return [{\n      points: points\n    }, {\n      points: points\n    }];\n  }\n\n  intersections.sort(function (a, b) {\n    return a.projPt - b.projPt;\n  });\n  var splitPt0 = intersections[0];\n  var splitPt1 = intersections[intersections.length - 1];\n\n  if (splitPt1.idx < splitPt0.idx) {\n    var tmp = splitPt0;\n    splitPt0 = splitPt1;\n    splitPt1 = tmp;\n  }\n\n  var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n  var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n  var newPolyA = [splitPt0Arr];\n  var newPolyB = [splitPt1Arr];\n\n  for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n    addToPoly(newPolyA, points[i].slice());\n  }\n\n  addToPoly(newPolyA, splitPt1Arr);\n  addToPoly(newPolyA, splitPt0Arr);\n\n  for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n    addToPoly(newPolyB, points[i % len].slice());\n  }\n\n  addToPoly(newPolyB, splitPt0Arr);\n  addToPoly(newPolyB, splitPt1Arr);\n  return [{\n    points: newPolyA\n  }, {\n    points: newPolyB\n  }];\n}\n\nfunction binaryDividePolygon(polygonShape) {\n  var points = polygonShape.points;\n  var min = [];\n  var max = [];\n  fromPoints(points, min, max);\n  var boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  var width = boundingRect.width;\n  var height = boundingRect.height;\n  var x = boundingRect.x;\n  var y = boundingRect.y;\n  var pt0 = new Point();\n  var pt1 = new Point();\n\n  if (width > height) {\n    pt0.x = pt1.x = x + width / 2;\n    pt0.y = y;\n    pt1.y = y + height;\n  } else {\n    pt0.y = pt1.y = y + height / 2;\n    pt0.x = x;\n    pt1.x = x + width;\n  }\n\n  return splitPolygonByLine(points, pt0, pt1);\n}\n\nfunction binaryDivideRecursive(divider, shape, count, out) {\n  if (count === 1) {\n    out.push(shape);\n  } else {\n    var mid = Math.floor(count / 2);\n    var sub = divider(shape);\n    binaryDivideRecursive(divider, sub[0], mid, out);\n    binaryDivideRecursive(divider, sub[1], count - mid, out);\n  }\n\n  return out;\n}\n\nexport function clone(path, count) {\n  var paths = [];\n\n  for (var i = 0; i < count; i++) {\n    paths.push(clonePath(path));\n  }\n\n  return paths;\n}\n\nfunction copyPathProps(source, target) {\n  target.setStyle(source.style);\n  target.z = source.z;\n  target.z2 = source.z2;\n  target.zlevel = source.zlevel;\n}\n\nfunction polygonConvert(points) {\n  var out = [];\n\n  for (var i = 0; i < points.length;) {\n    out.push([points[i++], points[i++]]);\n  }\n\n  return out;\n}\n\nexport function split(path, count) {\n  var outShapes = [];\n  var shape = path.shape;\n  var OutShapeCtor;\n\n  switch (path.type) {\n    case 'rect':\n      divideRect(shape, count, outShapes);\n      OutShapeCtor = Rect;\n      break;\n\n    case 'sector':\n      divideSector(shape, count, outShapes);\n      OutShapeCtor = Sector;\n      break;\n\n    case 'circle':\n      divideSector({\n        r0: 0,\n        r: shape.r,\n        startAngle: 0,\n        endAngle: Math.PI * 2,\n        cx: shape.cx,\n        cy: shape.cy\n      }, count, outShapes);\n      OutShapeCtor = Sector;\n      break;\n\n    default:\n      var m = path.getComputedTransform();\n      var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n      var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) {\n        return polygonConvert(poly);\n      });\n      var polygonCount = polygons.length;\n\n      if (polygonCount === 0) {\n        binaryDivideRecursive(binaryDividePolygon, {\n          points: polygons[0]\n        }, count, outShapes);\n      } else if (polygonCount === count) {\n        for (var i = 0; i < polygonCount; i++) {\n          outShapes.push({\n            points: polygons[i]\n          });\n        }\n      } else {\n        var totalArea_1 = 0;\n        var items = map(polygons, function (poly) {\n          var min = [];\n          var max = [];\n          fromPoints(poly, min, max);\n          var area = (max[1] - min[1]) * (max[0] - min[0]);\n          totalArea_1 += area;\n          return {\n            poly: poly,\n            area: area\n          };\n        });\n        items.sort(function (a, b) {\n          return b.area - a.area;\n        });\n        var left = count;\n\n        for (var i = 0; i < polygonCount; i++) {\n          var item = items[i];\n\n          if (left <= 0) {\n            break;\n          }\n\n          var selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count);\n\n          if (selfCount < 0) {\n            continue;\n          }\n\n          binaryDivideRecursive(binaryDividePolygon, {\n            points: item.poly\n          }, selfCount, outShapes);\n          left -= selfCount;\n        }\n\n        ;\n      }\n\n      OutShapeCtor = Polygon;\n      break;\n  }\n\n  if (!OutShapeCtor) {\n    return clone(path, count);\n  }\n\n  var out = [];\n\n  for (var i = 0; i < outShapes.length; i++) {\n    var subPath = new OutShapeCtor();\n    subPath.setShape(outShapes[i]);\n    copyPathProps(path, subPath);\n    out.push(subPath);\n  }\n\n  return out;\n}","map":{"version":3,"names":["fromPoints","BoundingRect","Point","map","Polygon","Rect","Sector","pathToPolygons","clonePath","getDividingGrids","dimSize","rowDim","count","rowSize","columnSize","ratio","Math","abs","rowCount","ceil","sqrt","columnCount","floor","grids","i","push","currentCount","remained","divideSector","sectorShape","outShapes","r0","r","startAngle","endAngle","angle","arcLen","deltaR","isAngleRow","length","row","column","newShape","clockwise","cx","cy","divideRect","rectShape","width","height","isHorizontalRow","rowSizeDim","columnSizeDim","columnDim","x","y","crossProduct2d","x1","y1","x2","y2","lineLineIntersect","a1x","a1y","a2x","a2y","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","b1a1x","b1a1y","p","projPtOnLine","pt","lineA","lineB","dir","sub","normalize","dir2","len","dot","addToPoly","poly","last","splitPolygonByLine","points","intersections","p0","p1","intersectionPt","projPt","idx","sort","a","b","splitPt0","splitPt1","tmp","splitPt0Arr","splitPt1Arr","newPolyA","newPolyB","slice","binaryDividePolygon","polygonShape","min","max","boundingRect","pt0","pt1","binaryDivideRecursive","divider","shape","out","mid","clone","path","paths","copyPathProps","source","target","setStyle","style","z","z2","zlevel","polygonConvert","split","OutShapeCtor","type","PI","m","getComputedTransform","scale","polygons","getUpdatedPathProxy","polygonCount","totalArea_1","items","area","left","item","selfCount","subPath","setShape"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/zrender/lib/tool/dividePath.js"],"sourcesContent":["import { fromPoints } from '../core/bbox.js';\nimport BoundingRect from '../core/BoundingRect.js';\nimport Point from '../core/Point.js';\nimport { map } from '../core/util.js';\nimport Polygon from '../graphic/shape/Polygon.js';\nimport Rect from '../graphic/shape/Rect.js';\nimport Sector from '../graphic/shape/Sector.js';\nimport { pathToPolygons } from './convertPath.js';\nimport { clonePath } from './path.js';\nfunction getDividingGrids(dimSize, rowDim, count) {\n    var rowSize = dimSize[rowDim];\n    var columnSize = dimSize[1 - rowDim];\n    var ratio = Math.abs(rowSize / columnSize);\n    var rowCount = Math.ceil(Math.sqrt(ratio * count));\n    var columnCount = Math.floor(count / rowCount);\n    if (columnCount === 0) {\n        columnCount = 1;\n        rowCount = count;\n    }\n    var grids = [];\n    for (var i = 0; i < rowCount; i++) {\n        grids.push(columnCount);\n    }\n    var currentCount = rowCount * columnCount;\n    var remained = count - currentCount;\n    if (remained > 0) {\n        for (var i = 0; i < remained; i++) {\n            grids[i % rowCount] += 1;\n        }\n    }\n    return grids;\n}\nfunction divideSector(sectorShape, count, outShapes) {\n    var r0 = sectorShape.r0;\n    var r = sectorShape.r;\n    var startAngle = sectorShape.startAngle;\n    var endAngle = sectorShape.endAngle;\n    var angle = Math.abs(endAngle - startAngle);\n    var arcLen = angle * r;\n    var deltaR = r - r0;\n    var isAngleRow = arcLen > Math.abs(deltaR);\n    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            if (isAngleRow) {\n                newShape.startAngle = startAngle + rowSize * row;\n                newShape.endAngle = startAngle + rowSize * (row + 1);\n                newShape.r0 = r0 + columnSize * column;\n                newShape.r = r0 + columnSize * (column + 1);\n            }\n            else {\n                newShape.startAngle = startAngle + columnSize * column;\n                newShape.endAngle = startAngle + columnSize * (column + 1);\n                newShape.r0 = r0 + rowSize * row;\n                newShape.r = r0 + rowSize * (row + 1);\n            }\n            newShape.clockwise = sectorShape.clockwise;\n            newShape.cx = sectorShape.cx;\n            newShape.cy = sectorShape.cy;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction divideRect(rectShape, count, outShapes) {\n    var width = rectShape.width;\n    var height = rectShape.height;\n    var isHorizontalRow = width > height;\n    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n    var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n    var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n    var rowDim = isHorizontalRow ? 'x' : 'y';\n    var columnDim = isHorizontalRow ? 'y' : 'x';\n    var rowSize = rectShape[rowSizeDim] / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = rectShape[columnSizeDim] / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            newShape[rowDim] = row * rowSize;\n            newShape[columnDim] = column * columnSize;\n            newShape[rowSizeDim] = rowSize;\n            newShape[columnSizeDim] = columnSize;\n            newShape.x += rectShape.x;\n            newShape.y += rectShape.y;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction crossProduct2d(x1, y1, x2, y2) {\n    return x1 * y2 - x2 * y1;\n}\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n    var mx = a2x - a1x;\n    var my = a2y - a1y;\n    var nx = b2x - b1x;\n    var ny = b2y - b1y;\n    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n    if (Math.abs(nmCrossProduct) < 1e-6) {\n        return null;\n    }\n    var b1a1x = a1x - b1x;\n    var b1a1y = a1y - b1y;\n    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n    if (p < 0 || p > 1) {\n        return null;\n    }\n    return new Point(p * mx + a1x, p * my + a1y);\n}\nfunction projPtOnLine(pt, lineA, lineB) {\n    var dir = new Point();\n    Point.sub(dir, lineB, lineA);\n    dir.normalize();\n    var dir2 = new Point();\n    Point.sub(dir2, pt, lineA);\n    var len = dir2.dot(dir);\n    return len;\n}\nfunction addToPoly(poly, pt) {\n    var last = poly[poly.length - 1];\n    if (last && last[0] === pt[0] && last[1] === pt[1]) {\n        return;\n    }\n    poly.push(pt);\n}\nfunction splitPolygonByLine(points, lineA, lineB) {\n    var len = points.length;\n    var intersections = [];\n    for (var i = 0; i < len; i++) {\n        var p0 = points[i];\n        var p1 = points[(i + 1) % len];\n        var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n        if (intersectionPt) {\n            intersections.push({\n                projPt: projPtOnLine(intersectionPt, lineA, lineB),\n                pt: intersectionPt,\n                idx: i\n            });\n        }\n    }\n    if (intersections.length < 2) {\n        return [{ points: points }, { points: points }];\n    }\n    intersections.sort(function (a, b) {\n        return a.projPt - b.projPt;\n    });\n    var splitPt0 = intersections[0];\n    var splitPt1 = intersections[intersections.length - 1];\n    if (splitPt1.idx < splitPt0.idx) {\n        var tmp = splitPt0;\n        splitPt0 = splitPt1;\n        splitPt1 = tmp;\n    }\n    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n    var newPolyA = [splitPt0Arr];\n    var newPolyB = [splitPt1Arr];\n    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n        addToPoly(newPolyA, points[i].slice());\n    }\n    addToPoly(newPolyA, splitPt1Arr);\n    addToPoly(newPolyA, splitPt0Arr);\n    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n        addToPoly(newPolyB, points[i % len].slice());\n    }\n    addToPoly(newPolyB, splitPt0Arr);\n    addToPoly(newPolyB, splitPt1Arr);\n    return [{\n            points: newPolyA\n        }, {\n            points: newPolyB\n        }];\n}\nfunction binaryDividePolygon(polygonShape) {\n    var points = polygonShape.points;\n    var min = [];\n    var max = [];\n    fromPoints(points, min, max);\n    var boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    var width = boundingRect.width;\n    var height = boundingRect.height;\n    var x = boundingRect.x;\n    var y = boundingRect.y;\n    var pt0 = new Point();\n    var pt1 = new Point();\n    if (width > height) {\n        pt0.x = pt1.x = x + width / 2;\n        pt0.y = y;\n        pt1.y = y + height;\n    }\n    else {\n        pt0.y = pt1.y = y + height / 2;\n        pt0.x = x;\n        pt1.x = x + width;\n    }\n    return splitPolygonByLine(points, pt0, pt1);\n}\nfunction binaryDivideRecursive(divider, shape, count, out) {\n    if (count === 1) {\n        out.push(shape);\n    }\n    else {\n        var mid = Math.floor(count / 2);\n        var sub = divider(shape);\n        binaryDivideRecursive(divider, sub[0], mid, out);\n        binaryDivideRecursive(divider, sub[1], count - mid, out);\n    }\n    return out;\n}\nexport function clone(path, count) {\n    var paths = [];\n    for (var i = 0; i < count; i++) {\n        paths.push(clonePath(path));\n    }\n    return paths;\n}\nfunction copyPathProps(source, target) {\n    target.setStyle(source.style);\n    target.z = source.z;\n    target.z2 = source.z2;\n    target.zlevel = source.zlevel;\n}\nfunction polygonConvert(points) {\n    var out = [];\n    for (var i = 0; i < points.length;) {\n        out.push([points[i++], points[i++]]);\n    }\n    return out;\n}\nexport function split(path, count) {\n    var outShapes = [];\n    var shape = path.shape;\n    var OutShapeCtor;\n    switch (path.type) {\n        case 'rect':\n            divideRect(shape, count, outShapes);\n            OutShapeCtor = Rect;\n            break;\n        case 'sector':\n            divideSector(shape, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        case 'circle':\n            divideSector({\n                r0: 0, r: shape.r, startAngle: 0, endAngle: Math.PI * 2,\n                cx: shape.cx, cy: shape.cy\n            }, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        default:\n            var m = path.getComputedTransform();\n            var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n            var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) { return polygonConvert(poly); });\n            var polygonCount = polygons.length;\n            if (polygonCount === 0) {\n                binaryDivideRecursive(binaryDividePolygon, {\n                    points: polygons[0]\n                }, count, outShapes);\n            }\n            else if (polygonCount === count) {\n                for (var i = 0; i < polygonCount; i++) {\n                    outShapes.push({\n                        points: polygons[i]\n                    });\n                }\n            }\n            else {\n                var totalArea_1 = 0;\n                var items = map(polygons, function (poly) {\n                    var min = [];\n                    var max = [];\n                    fromPoints(poly, min, max);\n                    var area = (max[1] - min[1]) * (max[0] - min[0]);\n                    totalArea_1 += area;\n                    return { poly: poly, area: area };\n                });\n                items.sort(function (a, b) { return b.area - a.area; });\n                var left = count;\n                for (var i = 0; i < polygonCount; i++) {\n                    var item = items[i];\n                    if (left <= 0) {\n                        break;\n                    }\n                    var selfCount = i === polygonCount - 1\n                        ? left\n                        : Math.ceil(item.area / totalArea_1 * count);\n                    if (selfCount < 0) {\n                        continue;\n                    }\n                    binaryDivideRecursive(binaryDividePolygon, {\n                        points: item.poly\n                    }, selfCount, outShapes);\n                    left -= selfCount;\n                }\n                ;\n            }\n            OutShapeCtor = Polygon;\n            break;\n    }\n    if (!OutShapeCtor) {\n        return clone(path, count);\n    }\n    var out = [];\n    for (var i = 0; i < outShapes.length; i++) {\n        var subPath = new OutShapeCtor();\n        subPath.setShape(outShapes[i]);\n        copyPathProps(path, subPath);\n        out.push(subPath);\n    }\n    return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}