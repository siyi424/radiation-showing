{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, isArray } from 'zrender/lib/core/util.js';\n;\n/**\n * @param {Object} define\n * @return See the return of `createTask`.\n */\n\nexport function createTask(define) {\n  return new Task(define);\n}\n\nvar Task =\n/** @class */\nfunction () {\n  function Task(define) {\n    define = define || {};\n    this._reset = define.reset;\n    this._plan = define.plan;\n    this._count = define.count;\n    this._onDirty = define.onDirty;\n    this._dirty = true;\n  }\n  /**\n   * @param step Specified step.\n   * @param skip Skip customer perform call.\n   * @param modBy Sampling window size.\n   * @param modDataCount Sampling count.\n   * @return whether unfinished.\n   */\n\n\n  Task.prototype.perform = function (performArgs) {\n    var upTask = this._upstream;\n    var skip = performArgs && performArgs.skip; // TODO some refactor.\n    // Pull data. Must pull data each time, because context.data\n    // may be updated by Series.setData.\n\n    if (this._dirty && upTask) {\n      var context = this.context;\n      context.data = context.outputData = upTask.context.outputData;\n    }\n\n    if (this.__pipeline) {\n      this.__pipeline.currentTask = this;\n    }\n\n    var planResult;\n\n    if (this._plan && !skip) {\n      planResult = this._plan(this.context);\n    } // Support sharding by mod, which changes the render sequence and makes the rendered graphic\n    // elements uniformed distributed when progress, especially when moving or zooming.\n\n\n    var lastModBy = normalizeModBy(this._modBy);\n    var lastModDataCount = this._modDataCount || 0;\n    var modBy = normalizeModBy(performArgs && performArgs.modBy);\n    var modDataCount = performArgs && performArgs.modDataCount || 0;\n\n    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {\n      planResult = 'reset';\n    }\n\n    function normalizeModBy(val) {\n      !(val >= 1) && (val = 1); // jshint ignore:line\n\n      return val;\n    }\n\n    var forceFirstProgress;\n\n    if (this._dirty || planResult === 'reset') {\n      this._dirty = false;\n      forceFirstProgress = this._doReset(skip);\n    }\n\n    this._modBy = modBy;\n    this._modDataCount = modDataCount;\n    var step = performArgs && performArgs.step;\n\n    if (upTask) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert(upTask._outputDueEnd != null);\n      }\n\n      this._dueEnd = upTask._outputDueEnd;\n    } // DataTask or overallTask\n    else {\n      if (process.env.NODE_ENV !== 'production') {\n        assert(!this._progress || this._count);\n      }\n\n      this._dueEnd = this._count ? this._count(this.context) : Infinity;\n    } // Note: Stubs, that its host overall task let it has progress, has progress.\n    // If no progress, pass index from upstream to downstream each time plan called.\n\n\n    if (this._progress) {\n      var start = this._dueIndex;\n      var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);\n\n      if (!skip && (forceFirstProgress || start < end)) {\n        var progress = this._progress;\n\n        if (isArray(progress)) {\n          for (var i = 0; i < progress.length; i++) {\n            this._doProgress(progress[i], start, end, modBy, modDataCount);\n          }\n        } else {\n          this._doProgress(progress, start, end, modBy, modDataCount);\n        }\n      }\n\n      this._dueIndex = end; // If no `outputDueEnd`, assume that output data and\n      // input data is the same, so use `dueIndex` as `outputDueEnd`.\n\n      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;\n\n      if (process.env.NODE_ENV !== 'production') {\n        // ??? Can not rollback.\n        assert(outputDueEnd >= this._outputDueEnd);\n      }\n\n      this._outputDueEnd = outputDueEnd;\n    } else {\n      // (1) Some overall task has no progress.\n      // (2) Stubs, that its host overall task do not let it has progress, has no progress.\n      // This should always be performed so it can be passed to downstream.\n      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;\n    }\n\n    return this.unfinished();\n  };\n\n  Task.prototype.dirty = function () {\n    this._dirty = true;\n    this._onDirty && this._onDirty(this.context);\n  };\n\n  Task.prototype._doProgress = function (progress, start, end, modBy, modDataCount) {\n    iterator.reset(start, end, modBy, modDataCount);\n    this._callingProgress = progress;\n\n    this._callingProgress({\n      start: start,\n      end: end,\n      count: end - start,\n      next: iterator.next\n    }, this.context);\n  };\n\n  Task.prototype._doReset = function (skip) {\n    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;\n    this._settedOutputEnd = null;\n    var progress;\n    var forceFirstProgress;\n\n    if (!skip && this._reset) {\n      progress = this._reset(this.context);\n\n      if (progress && progress.progress) {\n        forceFirstProgress = progress.forceFirstProgress;\n        progress = progress.progress;\n      } // To simplify no progress checking, array must has item.\n\n\n      if (isArray(progress) && !progress.length) {\n        progress = null;\n      }\n    }\n\n    this._progress = progress;\n    this._modBy = this._modDataCount = null;\n    var downstream = this._downstream;\n    downstream && downstream.dirty();\n    return forceFirstProgress;\n  };\n\n  Task.prototype.unfinished = function () {\n    return this._progress && this._dueIndex < this._dueEnd;\n  };\n  /**\n   * @param downTask The downstream task.\n   * @return The downstream task.\n   */\n\n\n  Task.prototype.pipe = function (downTask) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(downTask && !downTask._disposed && downTask !== this);\n    } // If already downstream, do not dirty downTask.\n\n\n    if (this._downstream !== downTask || this._dirty) {\n      this._downstream = downTask;\n      downTask._upstream = this;\n      downTask.dirty();\n    }\n  };\n\n  Task.prototype.dispose = function () {\n    if (this._disposed) {\n      return;\n    }\n\n    this._upstream && (this._upstream._downstream = null);\n    this._downstream && (this._downstream._upstream = null);\n    this._dirty = false;\n    this._disposed = true;\n  };\n\n  Task.prototype.getUpstream = function () {\n    return this._upstream;\n  };\n\n  Task.prototype.getDownstream = function () {\n    return this._downstream;\n  };\n\n  Task.prototype.setOutputEnd = function (end) {\n    // This only happend in dataTask, dataZoom, map, currently.\n    // where dataZoom do not set end each time, but only set\n    // when reset. So we should record the setted end, in case\n    // that the stub of dataZoom perform again and earse the\n    // setted end by upstream.\n    this._outputDueEnd = this._settedOutputEnd = end;\n  };\n\n  return Task;\n}();\n\nexport { Task };\n\nvar iterator = function () {\n  var end;\n  var current;\n  var modBy;\n  var modDataCount;\n  var winCount;\n  var it = {\n    reset: function (s, e, sStep, sCount) {\n      current = s;\n      end = e;\n      modBy = sStep;\n      modDataCount = sCount;\n      winCount = Math.ceil(modDataCount / modBy);\n      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;\n    }\n  };\n  return it;\n\n  function sequentialNext() {\n    return current < end ? current++ : null;\n  }\n\n  function modNext() {\n    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);\n    var result = current >= end ? null : dataIndex < modDataCount ? dataIndex // If modDataCount is smaller than data.count() (consider `appendData` case),\n    // Use normal linear rendering mode.\n    : current;\n    current++;\n    return result;\n  }\n}(); ///////////////////////////////////////////////////////////\n// For stream debug (Should be commented out after used!)\n// @usage: printTask(this, 'begin');\n// @usage: printTask(this, null, {someExtraProp});\n// @usage: Use `__idxInPipeline` as conditional breakpiont.\n//\n// window.printTask = function (task: any, prefix: string, extra: { [key: string]: unknown }): void {\n//     window.ecTaskUID == null && (window.ecTaskUID = 0);\n//     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);\n//     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);\n//     let props = [];\n//     if (task.__pipeline) {\n//         let val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;\n//         props.push({text: '__idxInPipeline/total', value: val});\n//     } else {\n//         let stubCount = 0;\n//         task.agentStubMap.each(() => stubCount++);\n//         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});\n//     }\n//     props.push({text: 'uid', value: task.uidDebug});\n//     if (task.__pipeline) {\n//         props.push({text: 'pipelineId', value: task.__pipeline.id});\n//         task.agent && props.push(\n//             {text: 'stubFor', value: task.agent.uidDebug}\n//         );\n//     }\n//     props.push(\n//         {text: 'dirty', value: task._dirty},\n//         {text: 'dueIndex', value: task._dueIndex},\n//         {text: 'dueEnd', value: task._dueEnd},\n//         {text: 'outputDueEnd', value: task._outputDueEnd}\n//     );\n//     if (extra) {\n//         Object.keys(extra).forEach(key => {\n//             props.push({text: key, value: extra[key]});\n//         });\n//     }\n//     let args = ['color: blue'];\n//     let msg = `%c[${prefix || 'T'}] %c` + props.map(item => (\n//         args.push('color: green', 'color: red'),\n//         `${item.text}: %c${item.value}`\n//     )).join('%c, ');\n//     console.log.apply(console, [msg].concat(args));\n//     // console.log(this);\n// };\n// window.printPipeline = function (task: any, prefix: string) {\n//     const pipeline = task.__pipeline;\n//     let currTask = pipeline.head;\n//     while (currTask) {\n//         window.printTask(currTask, prefix);\n//         currTask = currTask._downstream;\n//     }\n// };\n// window.showChain = function (chainHeadTask) {\n//     var chain = [];\n//     var task = chainHeadTask;\n//     while (task) {\n//         chain.push({\n//             task: task,\n//             up: task._upstream,\n//             down: task._downstream,\n//             idxInPipeline: task.__idxInPipeline\n//         });\n//         task = task._downstream;\n//     }\n//     return chain;\n// };\n// window.findTaskInChain = function (task, chainHeadTask) {\n//     let chain = window.showChain(chainHeadTask);\n//     let result = [];\n//     for (let i = 0; i < chain.length; i++) {\n//         let chainItem = chain[i];\n//         if (chainItem.task === task) {\n//             result.push(i);\n//         }\n//     }\n//     return result;\n// };\n// window.printChainAEachInChainB = function (chainHeadTaskA, chainHeadTaskB) {\n//     let chainA = window.showChain(chainHeadTaskA);\n//     for (let i = 0; i < chainA.length; i++) {\n//         console.log('chainAIdx:', i, 'inChainB:', window.findTaskInChain(chainA[i].task, chainHeadTaskB));\n//     }\n// };","map":{"version":3,"names":["assert","isArray","createTask","define","Task","_reset","reset","_plan","plan","_count","count","_onDirty","onDirty","_dirty","prototype","perform","performArgs","upTask","_upstream","skip","context","data","outputData","__pipeline","currentTask","planResult","lastModBy","normalizeModBy","_modBy","lastModDataCount","_modDataCount","modBy","modDataCount","val","forceFirstProgress","_doReset","step","process","env","NODE_ENV","_outputDueEnd","_dueEnd","_progress","Infinity","start","_dueIndex","end","Math","min","progress","i","length","_doProgress","outputDueEnd","_settedOutputEnd","unfinished","dirty","iterator","_callingProgress","next","downstream","_downstream","pipe","downTask","_disposed","dispose","getUpstream","getDownstream","setOutputEnd","current","winCount","it","s","e","sStep","sCount","ceil","modNext","sequentialNext","dataIndex","result"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/core/task.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, isArray } from 'zrender/lib/core/util.js';\n;\n/**\n * @param {Object} define\n * @return See the return of `createTask`.\n */\n\nexport function createTask(define) {\n  return new Task(define);\n}\n\nvar Task =\n/** @class */\nfunction () {\n  function Task(define) {\n    define = define || {};\n    this._reset = define.reset;\n    this._plan = define.plan;\n    this._count = define.count;\n    this._onDirty = define.onDirty;\n    this._dirty = true;\n  }\n  /**\n   * @param step Specified step.\n   * @param skip Skip customer perform call.\n   * @param modBy Sampling window size.\n   * @param modDataCount Sampling count.\n   * @return whether unfinished.\n   */\n\n\n  Task.prototype.perform = function (performArgs) {\n    var upTask = this._upstream;\n    var skip = performArgs && performArgs.skip; // TODO some refactor.\n    // Pull data. Must pull data each time, because context.data\n    // may be updated by Series.setData.\n\n    if (this._dirty && upTask) {\n      var context = this.context;\n      context.data = context.outputData = upTask.context.outputData;\n    }\n\n    if (this.__pipeline) {\n      this.__pipeline.currentTask = this;\n    }\n\n    var planResult;\n\n    if (this._plan && !skip) {\n      planResult = this._plan(this.context);\n    } // Support sharding by mod, which changes the render sequence and makes the rendered graphic\n    // elements uniformed distributed when progress, especially when moving or zooming.\n\n\n    var lastModBy = normalizeModBy(this._modBy);\n    var lastModDataCount = this._modDataCount || 0;\n    var modBy = normalizeModBy(performArgs && performArgs.modBy);\n    var modDataCount = performArgs && performArgs.modDataCount || 0;\n\n    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {\n      planResult = 'reset';\n    }\n\n    function normalizeModBy(val) {\n      !(val >= 1) && (val = 1); // jshint ignore:line\n\n      return val;\n    }\n\n    var forceFirstProgress;\n\n    if (this._dirty || planResult === 'reset') {\n      this._dirty = false;\n      forceFirstProgress = this._doReset(skip);\n    }\n\n    this._modBy = modBy;\n    this._modDataCount = modDataCount;\n    var step = performArgs && performArgs.step;\n\n    if (upTask) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert(upTask._outputDueEnd != null);\n      }\n\n      this._dueEnd = upTask._outputDueEnd;\n    } // DataTask or overallTask\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(!this._progress || this._count);\n        }\n\n        this._dueEnd = this._count ? this._count(this.context) : Infinity;\n      } // Note: Stubs, that its host overall task let it has progress, has progress.\n    // If no progress, pass index from upstream to downstream each time plan called.\n\n\n    if (this._progress) {\n      var start = this._dueIndex;\n      var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);\n\n      if (!skip && (forceFirstProgress || start < end)) {\n        var progress = this._progress;\n\n        if (isArray(progress)) {\n          for (var i = 0; i < progress.length; i++) {\n            this._doProgress(progress[i], start, end, modBy, modDataCount);\n          }\n        } else {\n          this._doProgress(progress, start, end, modBy, modDataCount);\n        }\n      }\n\n      this._dueIndex = end; // If no `outputDueEnd`, assume that output data and\n      // input data is the same, so use `dueIndex` as `outputDueEnd`.\n\n      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;\n\n      if (process.env.NODE_ENV !== 'production') {\n        // ??? Can not rollback.\n        assert(outputDueEnd >= this._outputDueEnd);\n      }\n\n      this._outputDueEnd = outputDueEnd;\n    } else {\n      // (1) Some overall task has no progress.\n      // (2) Stubs, that its host overall task do not let it has progress, has no progress.\n      // This should always be performed so it can be passed to downstream.\n      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;\n    }\n\n    return this.unfinished();\n  };\n\n  Task.prototype.dirty = function () {\n    this._dirty = true;\n    this._onDirty && this._onDirty(this.context);\n  };\n\n  Task.prototype._doProgress = function (progress, start, end, modBy, modDataCount) {\n    iterator.reset(start, end, modBy, modDataCount);\n    this._callingProgress = progress;\n\n    this._callingProgress({\n      start: start,\n      end: end,\n      count: end - start,\n      next: iterator.next\n    }, this.context);\n  };\n\n  Task.prototype._doReset = function (skip) {\n    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;\n    this._settedOutputEnd = null;\n    var progress;\n    var forceFirstProgress;\n\n    if (!skip && this._reset) {\n      progress = this._reset(this.context);\n\n      if (progress && progress.progress) {\n        forceFirstProgress = progress.forceFirstProgress;\n        progress = progress.progress;\n      } // To simplify no progress checking, array must has item.\n\n\n      if (isArray(progress) && !progress.length) {\n        progress = null;\n      }\n    }\n\n    this._progress = progress;\n    this._modBy = this._modDataCount = null;\n    var downstream = this._downstream;\n    downstream && downstream.dirty();\n    return forceFirstProgress;\n  };\n\n  Task.prototype.unfinished = function () {\n    return this._progress && this._dueIndex < this._dueEnd;\n  };\n  /**\n   * @param downTask The downstream task.\n   * @return The downstream task.\n   */\n\n\n  Task.prototype.pipe = function (downTask) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(downTask && !downTask._disposed && downTask !== this);\n    } // If already downstream, do not dirty downTask.\n\n\n    if (this._downstream !== downTask || this._dirty) {\n      this._downstream = downTask;\n      downTask._upstream = this;\n      downTask.dirty();\n    }\n  };\n\n  Task.prototype.dispose = function () {\n    if (this._disposed) {\n      return;\n    }\n\n    this._upstream && (this._upstream._downstream = null);\n    this._downstream && (this._downstream._upstream = null);\n    this._dirty = false;\n    this._disposed = true;\n  };\n\n  Task.prototype.getUpstream = function () {\n    return this._upstream;\n  };\n\n  Task.prototype.getDownstream = function () {\n    return this._downstream;\n  };\n\n  Task.prototype.setOutputEnd = function (end) {\n    // This only happend in dataTask, dataZoom, map, currently.\n    // where dataZoom do not set end each time, but only set\n    // when reset. So we should record the setted end, in case\n    // that the stub of dataZoom perform again and earse the\n    // setted end by upstream.\n    this._outputDueEnd = this._settedOutputEnd = end;\n  };\n\n  return Task;\n}();\n\nexport { Task };\n\nvar iterator = function () {\n  var end;\n  var current;\n  var modBy;\n  var modDataCount;\n  var winCount;\n  var it = {\n    reset: function (s, e, sStep, sCount) {\n      current = s;\n      end = e;\n      modBy = sStep;\n      modDataCount = sCount;\n      winCount = Math.ceil(modDataCount / modBy);\n      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;\n    }\n  };\n  return it;\n\n  function sequentialNext() {\n    return current < end ? current++ : null;\n  }\n\n  function modNext() {\n    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);\n    var result = current >= end ? null : dataIndex < modDataCount ? dataIndex // If modDataCount is smaller than data.count() (consider `appendData` case),\n    // Use normal linear rendering mode.\n    : current;\n    current++;\n    return result;\n  }\n}(); ///////////////////////////////////////////////////////////\n// For stream debug (Should be commented out after used!)\n// @usage: printTask(this, 'begin');\n// @usage: printTask(this, null, {someExtraProp});\n// @usage: Use `__idxInPipeline` as conditional breakpiont.\n//\n// window.printTask = function (task: any, prefix: string, extra: { [key: string]: unknown }): void {\n//     window.ecTaskUID == null && (window.ecTaskUID = 0);\n//     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);\n//     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);\n//     let props = [];\n//     if (task.__pipeline) {\n//         let val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;\n//         props.push({text: '__idxInPipeline/total', value: val});\n//     } else {\n//         let stubCount = 0;\n//         task.agentStubMap.each(() => stubCount++);\n//         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});\n//     }\n//     props.push({text: 'uid', value: task.uidDebug});\n//     if (task.__pipeline) {\n//         props.push({text: 'pipelineId', value: task.__pipeline.id});\n//         task.agent && props.push(\n//             {text: 'stubFor', value: task.agent.uidDebug}\n//         );\n//     }\n//     props.push(\n//         {text: 'dirty', value: task._dirty},\n//         {text: 'dueIndex', value: task._dueIndex},\n//         {text: 'dueEnd', value: task._dueEnd},\n//         {text: 'outputDueEnd', value: task._outputDueEnd}\n//     );\n//     if (extra) {\n//         Object.keys(extra).forEach(key => {\n//             props.push({text: key, value: extra[key]});\n//         });\n//     }\n//     let args = ['color: blue'];\n//     let msg = `%c[${prefix || 'T'}] %c` + props.map(item => (\n//         args.push('color: green', 'color: red'),\n//         `${item.text}: %c${item.value}`\n//     )).join('%c, ');\n//     console.log.apply(console, [msg].concat(args));\n//     // console.log(this);\n// };\n// window.printPipeline = function (task: any, prefix: string) {\n//     const pipeline = task.__pipeline;\n//     let currTask = pipeline.head;\n//     while (currTask) {\n//         window.printTask(currTask, prefix);\n//         currTask = currTask._downstream;\n//     }\n// };\n// window.showChain = function (chainHeadTask) {\n//     var chain = [];\n//     var task = chainHeadTask;\n//     while (task) {\n//         chain.push({\n//             task: task,\n//             up: task._upstream,\n//             down: task._downstream,\n//             idxInPipeline: task.__idxInPipeline\n//         });\n//         task = task._downstream;\n//     }\n//     return chain;\n// };\n// window.findTaskInChain = function (task, chainHeadTask) {\n//     let chain = window.showChain(chainHeadTask);\n//     let result = [];\n//     for (let i = 0; i < chain.length; i++) {\n//         let chainItem = chain[i];\n//         if (chainItem.task === task) {\n//             result.push(i);\n//         }\n//     }\n//     return result;\n// };\n// window.printChainAEachInChainB = function (chainHeadTaskA, chainHeadTaskB) {\n//     let chainA = window.showChain(chainHeadTaskA);\n//     for (let i = 0; i < chainA.length; i++) {\n//         console.log('chainAIdx:', i, 'inChainB:', window.findTaskInChain(chainA[i].task, chainHeadTaskB));\n//     }\n// };"],"mappings":"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AGG,CAAV;MACA1B,GAAG,GAAG2B,CAAN;MACA1C,KAAK,GAAG2C,KAAR;MACA1C,YAAY,GAAG2C,MAAf;MACAL,QAAQ,GAAGvB,IAAI,CAAC6B,IAAL,CAAU5C,YAAY,GAAGD,KAAzB,CAAX;MACAwC,EAAE,CAACZ,IAAH,GAAU5B,KAAK,GAAG,CAAR,IAAaC,YAAY,GAAG,CAA5B,GAAgC6C,OAAhC,GAA0CC,cAApD;IACD;EARM,CAAT;EAUA,OAAOP,EAAP;;EAEA,SAASO,cAAT,GAA0B;IACxB,OAAOT,OAAO,GAAGvB,GAAV,GAAgBuB,OAAO,EAAvB,GAA4B,IAAnC;EACD;;EAED,SAASQ,OAAT,GAAmB;IACjB,IAAIE,SAAS,GAAGV,OAAO,GAAGC,QAAV,GAAqBvC,KAArB,GAA6BgB,IAAI,CAAC6B,IAAL,CAAUP,OAAO,GAAGC,QAApB,CAA7C;IACA,IAAIU,MAAM,GAAGX,OAAO,IAAIvB,GAAX,GAAiB,IAAjB,GAAwBiC,SAAS,GAAG/C,YAAZ,GAA2B+C,SAA3B,CAAqC;IAC1E;IADqC,EAEnCV,OAFF;IAGAA,OAAO;IACP,OAAOW,MAAP;EACD;AACF,CA9Bc,EAAf,C,CA8BK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}