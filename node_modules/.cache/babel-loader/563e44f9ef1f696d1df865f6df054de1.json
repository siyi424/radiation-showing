{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport Cartesian from './Cartesian.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport { applyTransform } from 'zrender/lib/core/vector.js';\nexport var cartesian2DDimensions = ['x', 'y'];\n\nfunction canCalculateAffineTransform(scale) {\n  return scale.type === 'interval' || scale.type === 'time';\n}\n\nvar Cartesian2D =\n/** @class */\nfunction (_super) {\n  __extends(Cartesian2D, _super);\n\n  function Cartesian2D() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'cartesian2d';\n    _this.dimensions = cartesian2DDimensions;\n    return _this;\n  }\n  /**\n   * Calculate an affine transform matrix if two axes are time or value.\n   * It's mainly for accelartion on the large time series data.\n   */\n\n\n  Cartesian2D.prototype.calcAffineTransform = function () {\n    this._transform = this._invTransform = null;\n    var xAxisScale = this.getAxis('x').scale;\n    var yAxisScale = this.getAxis('y').scale;\n\n    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n      return;\n    }\n\n    var xScaleExtent = xAxisScale.getExtent();\n    var yScaleExtent = yAxisScale.getExtent();\n    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n\n    if (!xScaleSpan || !yScaleSpan) {\n      return;\n    } // Accelerate data to point calculation on the special large time series data.\n\n\n    var scaleX = (end[0] - start[0]) / xScaleSpan;\n    var scaleY = (end[1] - start[1]) / yScaleSpan;\n    var translateX = start[0] - xScaleExtent[0] * scaleX;\n    var translateY = start[1] - yScaleExtent[0] * scaleY;\n    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n    this._invTransform = invert([], m);\n  };\n  /**\n   * Base axis will be used on stacking.\n   */\n\n\n  Cartesian2D.prototype.getBaseAxis = function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  };\n\n  Cartesian2D.prototype.containPoint = function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  };\n\n  Cartesian2D.prototype.containData = function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  };\n\n  Cartesian2D.prototype.containZone = function (data1, data2) {\n    var zoneDiag1 = this.dataToPoint(data1);\n    var zoneDiag2 = this.dataToPoint(data2);\n    var area = this.getArea();\n    var zone = new BoundingRect(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);\n    return area.intersect(zone);\n  };\n\n  Cartesian2D.prototype.dataToPoint = function (data, clamp, out) {\n    out = out || [];\n    var xVal = data[0];\n    var yVal = data[1]; // Fast path\n\n    if (this._transform // It's supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.\n    && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n      return applyTransform(out, data, this._transform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp));\n    return out;\n  };\n\n  Cartesian2D.prototype.clampData = function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  };\n\n  Cartesian2D.prototype.pointToData = function (point, clamp) {\n    var out = [];\n\n    if (this._invTransform) {\n      return applyTransform(out, point, this._invTransform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp);\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp);\n    return out;\n  };\n\n  Cartesian2D.prototype.getOtherAxis = function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  };\n  /**\n   * Get rect area of cartesian.\n   * Area will have a contain function to determine if a point is in the coordinate system.\n   */\n\n\n  Cartesian2D.prototype.getArea = function () {\n    var xExtent = this.getAxis('x').getGlobalExtent();\n    var yExtent = this.getAxis('y').getGlobalExtent();\n    var x = Math.min(xExtent[0], xExtent[1]);\n    var y = Math.min(yExtent[0], yExtent[1]);\n    var width = Math.max(xExtent[0], xExtent[1]) - x;\n    var height = Math.max(yExtent[0], yExtent[1]) - y;\n    return new BoundingRect(x, y, width, height);\n  };\n\n  return Cartesian2D;\n}(Cartesian);\n\n;\nexport default Cartesian2D;","map":{"version":3,"names":["__extends","BoundingRect","Cartesian","invert","applyTransform","cartesian2DDimensions","canCalculateAffineTransform","scale","type","Cartesian2D","_super","_this","apply","arguments","dimensions","prototype","calcAffineTransform","_transform","_invTransform","xAxisScale","getAxis","yAxisScale","xScaleExtent","getExtent","yScaleExtent","start","dataToPoint","end","xScaleSpan","yScaleSpan","scaleX","scaleY","translateX","translateY","m","getBaseAxis","getAxesByScale","containPoint","point","axisX","axisY","contain","toLocalCoord","containData","data","containZone","data1","data2","zoneDiag1","zoneDiag2","area","getArea","zone","intersect","clamp","out","xVal","yVal","isFinite","xAxis","yAxis","toGlobalCoord","dataToCoord","clampData","xScale","yScale","xAxisExtent","yAxisExtent","x","parse","y","Math","min","max","pointToData","coordToData","getOtherAxis","axis","dim","xExtent","getGlobalExtent","yExtent","width","height"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/coord/cartesian/Cartesian2D.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport Cartesian from './Cartesian.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport { applyTransform } from 'zrender/lib/core/vector.js';\nexport var cartesian2DDimensions = ['x', 'y'];\n\nfunction canCalculateAffineTransform(scale) {\n  return scale.type === 'interval' || scale.type === 'time';\n}\n\nvar Cartesian2D =\n/** @class */\nfunction (_super) {\n  __extends(Cartesian2D, _super);\n\n  function Cartesian2D() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'cartesian2d';\n    _this.dimensions = cartesian2DDimensions;\n    return _this;\n  }\n  /**\n   * Calculate an affine transform matrix if two axes are time or value.\n   * It's mainly for accelartion on the large time series data.\n   */\n\n\n  Cartesian2D.prototype.calcAffineTransform = function () {\n    this._transform = this._invTransform = null;\n    var xAxisScale = this.getAxis('x').scale;\n    var yAxisScale = this.getAxis('y').scale;\n\n    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n      return;\n    }\n\n    var xScaleExtent = xAxisScale.getExtent();\n    var yScaleExtent = yAxisScale.getExtent();\n    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n\n    if (!xScaleSpan || !yScaleSpan) {\n      return;\n    } // Accelerate data to point calculation on the special large time series data.\n\n\n    var scaleX = (end[0] - start[0]) / xScaleSpan;\n    var scaleY = (end[1] - start[1]) / yScaleSpan;\n    var translateX = start[0] - xScaleExtent[0] * scaleX;\n    var translateY = start[1] - yScaleExtent[0] * scaleY;\n    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n    this._invTransform = invert([], m);\n  };\n  /**\n   * Base axis will be used on stacking.\n   */\n\n\n  Cartesian2D.prototype.getBaseAxis = function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  };\n\n  Cartesian2D.prototype.containPoint = function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  };\n\n  Cartesian2D.prototype.containData = function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  };\n\n  Cartesian2D.prototype.containZone = function (data1, data2) {\n    var zoneDiag1 = this.dataToPoint(data1);\n    var zoneDiag2 = this.dataToPoint(data2);\n    var area = this.getArea();\n    var zone = new BoundingRect(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);\n    return area.intersect(zone);\n  };\n\n  Cartesian2D.prototype.dataToPoint = function (data, clamp, out) {\n    out = out || [];\n    var xVal = data[0];\n    var yVal = data[1]; // Fast path\n\n    if (this._transform // It's supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.\n    && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n      return applyTransform(out, data, this._transform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp));\n    return out;\n  };\n\n  Cartesian2D.prototype.clampData = function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  };\n\n  Cartesian2D.prototype.pointToData = function (point, clamp) {\n    var out = [];\n\n    if (this._invTransform) {\n      return applyTransform(out, point, this._invTransform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp);\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp);\n    return out;\n  };\n\n  Cartesian2D.prototype.getOtherAxis = function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  };\n  /**\n   * Get rect area of cartesian.\n   * Area will have a contain function to determine if a point is in the coordinate system.\n   */\n\n\n  Cartesian2D.prototype.getArea = function () {\n    var xExtent = this.getAxis('x').getGlobalExtent();\n    var yExtent = this.getAxis('y').getGlobalExtent();\n    var x = Math.min(xExtent[0], xExtent[1]);\n    var y = Math.min(yExtent[0], yExtent[1]);\n    var width = Math.max(xExtent[0], xExtent[1]) - x;\n    var height = Math.max(yExtent[0], yExtent[1]) - y;\n    return new BoundingRect(x, y, width, height);\n  };\n\n  return Cartesian2D;\n}(Cartesian);\n\n;\nexport default Cartesian2D;"],"mappings":"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"},"metadata":{},"sourceType":"module"}