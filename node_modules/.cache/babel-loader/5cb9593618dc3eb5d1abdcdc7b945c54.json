{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\"; // Poly path support NaN point\n\nimport Path from 'zrender/lib/graphic/Path.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { cubicRootAt, cubicAt } from 'zrender/lib/core/curve.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar ECPolyline =\n/** @class */\nfunction (_super) {\n  __extends(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = PathProxy.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(Path);\n\nexport { ECPolyline };\n\nvar ECPolygonShape =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar ECPolygon =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(Path);\n\nexport { ECPolygon };","map":{"version":3,"names":["__extends","Path","PathProxy","cubicRootAt","cubicAt","mathMin","Math","min","mathMax","max","isPointNull","x","y","isNaN","drawSegment","ctx","points","start","segLen","allLen","dir","smooth","smoothMonotone","connectNulls","prevX","prevY","cpx0","cpy0","cpx1","cpy1","idx","k","dx","dy","nextIdx","nextX","nextY","tmpK","ratioNextSeg","vx","vy","nextCpx0","nextCpy0","dx0","dx1","dy0","dy1","lenPrevSeg","lenNextSeg","abs","dir_1","dir_2","sqrt","bezierCurveTo","lineTo","ECPolylineShape","smoothConstraint","ECPolyline","_super","opts","_this","call","type","prototype","getDefaultStyle","stroke","fill","getDefaultShape","buildPath","shape","i","len","length","getPointOn","xOrY","dim","path","createPathProxy","data","CMD","x0","y0","isDimX","roots","cmd","x2","y2","x3","y3","t","M","L","val","C","nRoot","i_1","t_1","ECPolygonShape","apply","arguments","ECPolygon","stackedOnPoints","stackedOnSmooth","closePath"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/chart/line/poly.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\"; // Poly path support NaN point\n\nimport Path from 'zrender/lib/graphic/Path.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { cubicRootAt, cubicAt } from 'zrender/lib/core/curve.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar ECPolyline =\n/** @class */\nfunction (_super) {\n  __extends(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = PathProxy.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(Path);\n\nexport { ECPolyline };\n\nvar ECPolygonShape =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar ECPolygon =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(Path);\n\nexport { ECPolygon };"],"mappings":"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"},"metadata":{},"sourceType":"module"}