{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c; // TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\nimport { isTypedArray, extend, assert, each, isObject, bind } from 'zrender/lib/core/util.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types.js';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\n\nvar DefaultDataProvider =\n/** @class */\nfunction () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam; // declare source is Source;\n\n    this._source = source;\n    var data = this._data = source.data; // Typed array. TODO IE10+?\n\n    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      extend(provider, methods);\n\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexport { DefaultDataProvider };\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\n\n\nexport function retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  } // Consider data may be not persistent.\n\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\n\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}","map":{"version":3,"names":["_a","_b","_c","isTypedArray","extend","assert","each","isObject","bind","getDataItemValue","createSourceFromSeriesDataOption","isSourceInstance","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ARRAY_ROWS","SERIES_LAYOUT_BY_COLUMN","SERIES_LAYOUT_BY_ROW","providerMethods","mountMethods","DefaultDataProvider","sourceParam","dimSize","source","_source","data","_data","sourceFormat","process","env","NODE_ENV","Error","_offset","_dimSize","prototype","getSource","count","getItem","idx","out","appendData","newData","clean","protoInitialize","proto","pure","persistent","internalField","provider","seriesLayoutBy","startIndex","dimsDef","dimensionsDefine","methods","getMethodMapKey","getItemForTypedArray","countForTypedArray","fillStorage","fillStorageForTypedArray","rawItemGetter","getRawSourceItemGetter","rawCounter","getRawSourceDataCounter","offset","i","start","end","storage","extent","dim","dimExtent","min","Infinity","max","arr","val","length","appendDataSimply","newCol","key","oldCol","push","getItemSimply","rawData","rawSourceItemGetterMap","item","row","dimName","name","col","method","countSimply","rawSourceDataCounterMap","Math","getRawValueSimply","dataItem","dimIndex","property","rawSourceValueGetterMap","value","Array","getRawSourceValueGetter","retrieveRawValue","dataIndex","getRawDataItem","store","getStore","getDimensionIndex","getDimensionProperty","result","retrieveRawAttr","attr"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/data/helper/dataProvider.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c; // TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\nimport { isTypedArray, extend, assert, each, isObject, bind } from 'zrender/lib/core/util.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types.js';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\n\nvar DefaultDataProvider =\n/** @class */\nfunction () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam; // declare source is Source;\n\n    this._source = source;\n    var data = this._data = source.data; // Typed array. TODO IE10+?\n\n    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      extend(provider, methods);\n\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexport { DefaultDataProvider };\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\n\n\nexport function retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  } // Consider data may be not persistent.\n\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\n\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}"],"mappings":";;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,C,CAAgB;AAChB;AACA;;;AAGA,SAASC,YAAT,EAAuBC,MAAvB,EAA+BC,MAA/B,EAAuCC,IAAvC,EAA6CC,QAA7C,EAAuDC,IAAvD,QAAmE,0BAAnE;AACA,SAASC,gBAAT,QAAiC,qBAAjC;AACA,SAASC,gCAAT,EAA2CC,gBAA3C,QAAmE,cAAnE;AACA,SAASC,sBAAT,EAAiCC,yBAAjC,EAA4DC,2BAA5D,EAAyFC,yBAAzF,EAAoHC,wBAApH,EAA8IC,uBAA9I,EAAuKC,oBAAvK,QAAmM,qBAAnM;AACA,IAAIC,eAAJ;AACA,IAAIC,YAAJ;AACA;AACA;AACA;AACA;;AAEA,IAAIC,mBAAmB;AACvB;AACA,YAAY;EACV,SAASA,mBAAT,CAA6BC,WAA7B,EAA0CC,OAA1C,EAAmD;IACjD;IACA,IAAIC,MAAM,GAAG,CAACb,gBAAgB,CAACW,WAAD,CAAjB,GAAiCZ,gCAAgC,CAACY,WAAD,CAAjE,GAAiFA,WAA9F,CAFiD,CAE0D;;IAE3G,KAAKG,OAAL,GAAeD,MAAf;IACA,IAAIE,IAAI,GAAG,KAAKC,KAAL,GAAaH,MAAM,CAACE,IAA/B,CALiD,CAKZ;;IAErC,IAAIF,MAAM,CAACI,YAAP,KAAwBb,yBAA5B,EAAuD;MACrD,IAAIc,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACzC,IAAIR,OAAO,IAAI,IAAf,EAAqB;UACnB,MAAM,IAAIS,KAAJ,CAAU,8CAAV,CAAN;QACD;MACF;;MAED,KAAKC,OAAL,GAAe,CAAf;MACA,KAAKC,QAAL,GAAgBX,OAAhB;MACA,KAAKI,KAAL,GAAaD,IAAb;IACD;;IAEDN,YAAY,CAAC,IAAD,EAAOM,IAAP,EAAaF,MAAb,CAAZ;EACD;;EAEDH,mBAAmB,CAACc,SAApB,CAA8BC,SAA9B,GAA0C,YAAY;IACpD,OAAO,KAAKX,OAAZ;EACD,CAFD;;EAIAJ,mBAAmB,CAACc,SAApB,CAA8BE,KAA9B,GAAsC,YAAY;IAChD,OAAO,CAAP;EACD,CAFD;;EAIAhB,mBAAmB,CAACc,SAApB,CAA8BG,OAA9B,GAAwC,UAAUC,GAAV,EAAeC,GAAf,EAAoB;IAC1D;EACD,CAFD;;EAIAnB,mBAAmB,CAACc,SAApB,CAA8BM,UAA9B,GAA2C,UAAUC,OAAV,EAAmB,CAAE,CAAhE;;EAEArB,mBAAmB,CAACc,SAApB,CAA8BQ,KAA9B,GAAsC,YAAY,CAAE,CAApD;;EAEAtB,mBAAmB,CAACuB,eAApB,GAAsC,YAAY;IAChD;IACA;IACA,IAAIC,KAAK,GAAGxB,mBAAmB,CAACc,SAAhC;IACAU,KAAK,CAACC,IAAN,GAAa,KAAb;IACAD,KAAK,CAACE,UAAN,GAAmB,IAAnB;EACD,CANqC,EAAtC;;EAQA1B,mBAAmB,CAAC2B,aAApB,GAAoC,YAAY;IAC9C,IAAIhD,EAAJ;;IAEAoB,YAAY,GAAG,UAAU6B,QAAV,EAAoBvB,IAApB,EAA0BF,MAA1B,EAAkC;MAC/C,IAAII,YAAY,GAAGJ,MAAM,CAACI,YAA1B;MACA,IAAIsB,cAAc,GAAG1B,MAAM,CAAC0B,cAA5B;MACA,IAAIC,UAAU,GAAG3B,MAAM,CAAC2B,UAAxB;MACA,IAAIC,OAAO,GAAG5B,MAAM,CAAC6B,gBAArB;MACA,IAAIC,OAAO,GAAGnC,eAAe,CAACoC,eAAe,CAAC3B,YAAD,EAAesB,cAAf,CAAhB,CAA7B;;MAEA,IAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACzC1B,MAAM,CAACiD,OAAD,EAAU,4BAA4B1B,YAAtC,CAAN;MACD;;MAEDxB,MAAM,CAAC6C,QAAD,EAAWK,OAAX,CAAN;;MAEA,IAAI1B,YAAY,KAAKb,yBAArB,EAAgD;QAC9CkC,QAAQ,CAACX,OAAT,GAAmBkB,oBAAnB;QACAP,QAAQ,CAACZ,KAAT,GAAiBoB,kBAAjB;QACAR,QAAQ,CAACS,WAAT,GAAuBC,wBAAvB;MACD,CAJD,MAIO;QACL,IAAIC,aAAa,GAAGC,sBAAsB,CAACjC,YAAD,EAAesB,cAAf,CAA1C;QACAD,QAAQ,CAACX,OAAT,GAAmB9B,IAAI,CAACoD,aAAD,EAAgB,IAAhB,EAAsBlC,IAAtB,EAA4ByB,UAA5B,EAAwCC,OAAxC,CAAvB;QACA,IAAIU,UAAU,GAAGC,uBAAuB,CAACnC,YAAD,EAAesB,cAAf,CAAxC;QACAD,QAAQ,CAACZ,KAAT,GAAiB7B,IAAI,CAACsD,UAAD,EAAa,IAAb,EAAmBpC,IAAnB,EAAyByB,UAAzB,EAAqCC,OAArC,CAArB;MACD;IACF,CAvBD;;IAyBA,IAAII,oBAAoB,GAAG,UAAUjB,GAAV,EAAeC,GAAf,EAAoB;MAC7CD,GAAG,GAAGA,GAAG,GAAG,KAAKN,OAAjB;MACAO,GAAG,GAAGA,GAAG,IAAI,EAAb;MACA,IAAId,IAAI,GAAG,KAAKC,KAAhB;MACA,IAAIJ,OAAO,GAAG,KAAKW,QAAnB;MACA,IAAI8B,MAAM,GAAGzC,OAAO,GAAGgB,GAAvB;;MAEA,KAAK,IAAI0B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1C,OAApB,EAA6B0C,CAAC,EAA9B,EAAkC;QAChCzB,GAAG,CAACyB,CAAD,CAAH,GAASvC,IAAI,CAACsC,MAAM,GAAGC,CAAV,CAAb;MACD;;MAED,OAAOzB,GAAP;IACD,CAZD;;IAcA,IAAImB,wBAAwB,GAAG,UAAUO,KAAV,EAAiBC,GAAjB,EAAsBC,OAAtB,EAA+BC,MAA/B,EAAuC;MACpE,IAAI3C,IAAI,GAAG,KAAKC,KAAhB;MACA,IAAIJ,OAAO,GAAG,KAAKW,QAAnB;;MAEA,KAAK,IAAIoC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG/C,OAAxB,EAAiC+C,GAAG,EAApC,EAAwC;QACtC,IAAIC,SAAS,GAAGF,MAAM,CAACC,GAAD,CAAtB;QACA,IAAIE,GAAG,GAAGD,SAAS,CAAC,CAAD,CAAT,IAAgB,IAAhB,GAAuBE,QAAvB,GAAkCF,SAAS,CAAC,CAAD,CAArD;QACA,IAAIG,GAAG,GAAGH,SAAS,CAAC,CAAD,CAAT,IAAgB,IAAhB,GAAuB,CAACE,QAAxB,GAAmCF,SAAS,CAAC,CAAD,CAAtD;QACA,IAAIlC,KAAK,GAAG8B,GAAG,GAAGD,KAAlB;QACA,IAAIS,GAAG,GAAGP,OAAO,CAACE,GAAD,CAAjB;;QAEA,KAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAApB,EAA2B4B,CAAC,EAA5B,EAAgC;UAC9B;UACA,IAAIW,GAAG,GAAGlD,IAAI,CAACuC,CAAC,GAAG1C,OAAJ,GAAc+C,GAAf,CAAd;UACAK,GAAG,CAACT,KAAK,GAAGD,CAAT,CAAH,GAAiBW,GAAjB;UACAA,GAAG,GAAGJ,GAAN,KAAcA,GAAG,GAAGI,GAApB;UACAA,GAAG,GAAGF,GAAN,KAAcA,GAAG,GAAGE,GAApB;QACD;;QAEDL,SAAS,CAAC,CAAD,CAAT,GAAeC,GAAf;QACAD,SAAS,CAAC,CAAD,CAAT,GAAeG,GAAf;MACD;IACF,CAtBD;;IAwBA,IAAIjB,kBAAkB,GAAG,YAAY;MACnC,OAAO,KAAK9B,KAAL,GAAa,KAAKA,KAAL,CAAWkD,MAAX,GAAoB,KAAK3C,QAAtC,GAAiD,CAAxD;IACD,CAFD;;IAIAf,eAAe,IAAInB,EAAE,GAAG,EAAL,EAASA,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCC,uBAAlC,CAAF,GAA+D;MACzF6B,IAAI,EAAE,IADmF;MAEzFL,UAAU,EAAEqC;IAF6E,CAAxE,EAGhB9E,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCE,oBAAlC,CAAF,GAA4D;MAC7D4B,IAAI,EAAE,IADuD;MAE7DL,UAAU,EAAE,YAAY;QACtB,MAAM,IAAIT,KAAJ,CAAU,2DAAV,CAAN;MACD;IAJ4D,CAH5C,EAQhBhC,EAAE,CAACa,yBAAD,CAAF,GAAgC;MACjCiC,IAAI,EAAE,IAD2B;MAEjCL,UAAU,EAAEqC;IAFqB,CARhB,EAWhB9E,EAAE,CAACc,2BAAD,CAAF,GAAkC;MACnCgC,IAAI,EAAE,IAD6B;MAEnCL,UAAU,EAAE,UAAUC,OAAV,EAAmB;QAC7B,IAAIhB,IAAI,GAAG,KAAKC,KAAhB;QACArB,IAAI,CAACoC,OAAD,EAAU,UAAUqC,MAAV,EAAkBC,GAAlB,EAAuB;UACnC,IAAIC,MAAM,GAAGvD,IAAI,CAACsD,GAAD,CAAJ,KAActD,IAAI,CAACsD,GAAD,CAAJ,GAAY,EAA1B,CAAb;;UAEA,KAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAACc,MAAM,IAAI,EAAX,EAAeF,MAAnC,EAA2CZ,CAAC,EAA5C,EAAgD;YAC9CgB,MAAM,CAACC,IAAP,CAAYH,MAAM,CAACd,CAAD,CAAlB;UACD;QACF,CANG,CAAJ;MAOD;IAXkC,CAXlB,EAuBhBjE,EAAE,CAACY,sBAAD,CAAF,GAA6B;MAC9B6B,UAAU,EAAEqC;IADkB,CAvBb,EAyBhB9E,EAAE,CAACe,yBAAD,CAAF,GAAgC;MACjCgC,UAAU,EAAE,KADqB;MAEjCD,IAAI,EAAE,IAF2B;MAGjCL,UAAU,EAAE,UAAUC,OAAV,EAAmB;QAC7B,IAAIb,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;UACzC1B,MAAM,CAACF,YAAY,CAACuC,OAAD,CAAb,EAAwB,uEAAxB,CAAN;QACD;;QAED,KAAKf,KAAL,GAAae,OAAb;MACD,CATgC;MAUjC;MACAC,KAAK,EAAE,YAAY;QACjB;QACA,KAAKV,OAAL,IAAgB,KAAKI,KAAL,EAAhB;QACA,KAAKV,KAAL,GAAa,IAAb;MACD;IAfgC,CAzBhB,EAyChB3B,EAzCY,CAAf;;IA2CA,SAAS8E,gBAAT,CAA0BpC,OAA1B,EAAmC;MACjC,KAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,OAAO,CAACmC,MAA5B,EAAoCZ,CAAC,EAArC,EAAyC;QACvC,KAAKtC,KAAL,CAAWuD,IAAX,CAAgBxC,OAAO,CAACuB,CAAD,CAAvB;MACD;IACF;EACF,CAtHmC,EAApC;;EAwHA,OAAO5C,mBAAP;AACD,CAxKD,EAFA;;AA4KA,SAASA,mBAAT;;AAEA,IAAI8D,aAAa,GAAG,UAAUC,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6C;EAC/D,OAAO6C,OAAO,CAAC7C,GAAD,CAAd;AACD,CAFD;;AAIA,IAAI8C,sBAAsB,IAAIrF,EAAE,GAAG,EAAL,EAASA,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCC,uBAAlC,CAAF,GAA+D,UAAUmE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6C;EACjJ,OAAO6C,OAAO,CAAC7C,GAAG,GAAGY,UAAP,CAAd;AACD,CAF6B,EAE3BnD,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCE,oBAAlC,CAAF,GAA4D,UAAUkE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6CC,GAA7C,EAAkD;EAC/GD,GAAG,IAAIY,UAAP;EACA,IAAImC,IAAI,GAAG9C,GAAG,IAAI,EAAlB;EACA,IAAId,IAAI,GAAG0D,OAAX;;EAEA,KAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvC,IAAI,CAACmD,MAAzB,EAAiCZ,CAAC,EAAlC,EAAsC;IACpC,IAAIsB,GAAG,GAAG7D,IAAI,CAACuC,CAAD,CAAd;IACAqB,IAAI,CAACrB,CAAD,CAAJ,GAAUsB,GAAG,GAAGA,GAAG,CAAChD,GAAD,CAAN,GAAc,IAA3B;EACD;;EAED,OAAO+C,IAAP;AACD,CAb6B,EAa3BtF,EAAE,CAACa,yBAAD,CAAF,GAAgCsE,aAbL,EAaoBnF,EAAE,CAACc,2BAAD,CAAF,GAAkC,UAAUsE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6CC,GAA7C,EAAkD;EACpI,IAAI8C,IAAI,GAAG9C,GAAG,IAAI,EAAlB;;EAEA,KAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,OAAO,CAACyB,MAA5B,EAAoCZ,CAAC,EAArC,EAAyC;IACvC,IAAIuB,OAAO,GAAGpC,OAAO,CAACa,CAAD,CAAP,CAAWwB,IAAzB;;IAEA,IAAI5D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACzC,IAAIyD,OAAO,IAAI,IAAf,EAAqB;QACnB,MAAM,IAAIxD,KAAJ,EAAN;MACD;IACF;;IAED,IAAI0D,GAAG,GAAGN,OAAO,CAACI,OAAD,CAAjB;IACAF,IAAI,CAACrB,CAAD,CAAJ,GAAUyB,GAAG,GAAGA,GAAG,CAACnD,GAAD,CAAN,GAAc,IAA3B;EACD;;EAED,OAAO+C,IAAP;AACD,CA9B6B,EA8B3BtF,EAAE,CAACY,sBAAD,CAAF,GAA6BuE,aA9BF,EA8BiBnF,EA9BrB,CAA1B;AA+BA,OAAO,SAAS6D,sBAAT,CAAgCjC,YAAhC,EAA8CsB,cAA9C,EAA8D;EACnE,IAAIyC,MAAM,GAAGN,sBAAsB,CAAC9B,eAAe,CAAC3B,YAAD,EAAesB,cAAf,CAAhB,CAAnC;;EAEA,IAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC1B,MAAM,CAACsF,MAAD,EAAS,iCAAiC/D,YAAjC,GAAgD,MAAhD,GAAyDsB,cAAzD,GAA0E,IAAnF,CAAN;EACD;;EAED,OAAOyC,MAAP;AACD;;AAED,IAAIC,WAAW,GAAG,UAAUR,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;EACxD,OAAOgC,OAAO,CAACP,MAAf;AACD,CAFD;;AAIA,IAAIgB,uBAAuB,IAAI5F,EAAE,GAAG,EAAL,EAASA,EAAE,CAACe,wBAAwB,GAAG,GAA3B,GAAiCC,uBAAlC,CAAF,GAA+D,UAAUmE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;EAC7I,OAAO0C,IAAI,CAACpB,GAAL,CAAS,CAAT,EAAYU,OAAO,CAACP,MAAR,GAAiB1B,UAA7B,CAAP;AACD,CAF8B,EAE5BlD,EAAE,CAACe,wBAAwB,GAAG,GAA3B,GAAiCE,oBAAlC,CAAF,GAA4D,UAAUkE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;EACrG,IAAImC,GAAG,GAAGH,OAAO,CAAC,CAAD,CAAjB;EACA,OAAOG,GAAG,GAAGO,IAAI,CAACpB,GAAL,CAAS,CAAT,EAAYa,GAAG,CAACV,MAAJ,GAAa1B,UAAzB,CAAH,GAA0C,CAApD;AACD,CAL8B,EAK5BlD,EAAE,CAACY,yBAAD,CAAF,GAAgC+E,WALJ,EAKiB3F,EAAE,CAACa,2BAAD,CAAF,GAAkC,UAAUsE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;EACxH,IAAIoC,OAAO,GAAGpC,OAAO,CAAC,CAAD,CAAP,CAAWqC,IAAzB;;EAEA,IAAI5D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC,IAAIyD,OAAO,IAAI,IAAf,EAAqB;MACnB,MAAM,IAAIxD,KAAJ,EAAN;IACD;EACF;;EAED,IAAI0D,GAAG,GAAGN,OAAO,CAACI,OAAD,CAAjB;EACA,OAAOE,GAAG,GAAGA,GAAG,CAACb,MAAP,GAAgB,CAA1B;AACD,CAhB8B,EAgB5B5E,EAAE,CAACW,sBAAD,CAAF,GAA6BgF,WAhBD,EAgBc3F,EAhBlB,CAA3B;AAiBA,OAAO,SAAS8D,uBAAT,CAAiCnC,YAAjC,EAA+CsB,cAA/C,EAA+D;EACpE,IAAIyC,MAAM,GAAGE,uBAAuB,CAACtC,eAAe,CAAC3B,YAAD,EAAesB,cAAf,CAAhB,CAApC;;EAEA,IAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC1B,MAAM,CAACsF,MAAD,EAAS,+BAA+B/D,YAA/B,GAA8C,MAA9C,GAAuDsB,cAAvD,GAAwE,IAAjF,CAAN;EACD;;EAED,OAAOyC,MAAP;AACD;;AAED,IAAII,iBAAiB,GAAG,UAAUC,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;EAC9D,OAAOF,QAAQ,CAACC,QAAD,CAAf;AACD,CAFD;;AAIA,IAAIE,uBAAuB,IAAIjG,EAAE,GAAG,EAAL,EAASA,EAAE,CAACc,wBAAD,CAAF,GAA+B+E,iBAAxC,EAA2D7F,EAAE,CAACW,yBAAD,CAAF,GAAgC,UAAUmF,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;EAChK,OAAOF,QAAQ,CAACE,QAAD,CAAf;AACD,CAF8B,EAE5BhG,EAAE,CAACY,2BAAD,CAAF,GAAkCiF,iBAFN,EAEyB7F,EAAE,CAACU,sBAAD,CAAF,GAA6B,UAAUoF,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;EAC3H;EACA;EACA,IAAIE,KAAK,GAAG3F,gBAAgB,CAACuF,QAAD,CAA5B;EACA,OAAO,EAAEI,KAAK,YAAYC,KAAnB,IAA4BD,KAA5B,GAAoCA,KAAK,CAACH,QAAD,CAAhD;AACD,CAP8B,EAO5B/F,EAAE,CAACa,yBAAD,CAAF,GAAgCgF,iBAPJ,EAOuB7F,EAP3B,CAA3B;AAQA,OAAO,SAASoG,uBAAT,CAAiC1E,YAAjC,EAA+C;EACpD,IAAI+D,MAAM,GAAGQ,uBAAuB,CAACvE,YAAD,CAApC;;EAEA,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC1B,MAAM,CAACsF,MAAD,EAAS,mCAAmC/D,YAAnC,GAAkD,IAA3D,CAAN;EACD;;EAED,OAAO+D,MAAP;AACD;;AAED,SAASpC,eAAT,CAAyB3B,YAAzB,EAAuCsB,cAAvC,EAAuD;EACrD,OAAOtB,YAAY,KAAKZ,wBAAjB,GAA4CY,YAAY,GAAG,GAAf,GAAqBsB,cAAjE,GAAkFtB,YAAzF;AACD,C,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAAS2E,gBAAT,CAA0B7E,IAA1B,EAAgC8E,SAAhC,EAA2C;AAClD;AACAlC,GAFO,EAEF;EACH,IAAI,CAAC5C,IAAL,EAAW;IACT;EACD,CAHE,CAGD;;;EAGF,IAAIsE,QAAQ,GAAGtE,IAAI,CAAC+E,cAAL,CAAoBD,SAApB,CAAf;;EAEA,IAAIR,QAAQ,IAAI,IAAhB,EAAsB;IACpB;EACD;;EAED,IAAIU,KAAK,GAAGhF,IAAI,CAACiF,QAAL,EAAZ;EACA,IAAI/E,YAAY,GAAG8E,KAAK,CAACtE,SAAN,GAAkBR,YAArC;;EAEA,IAAI0C,GAAG,IAAI,IAAX,EAAiB;IACf,IAAI2B,QAAQ,GAAGvE,IAAI,CAACkF,iBAAL,CAAuBtC,GAAvB,CAAf;IACA,IAAI4B,QAAQ,GAAGQ,KAAK,CAACG,oBAAN,CAA2BZ,QAA3B,CAAf;IACA,OAAOK,uBAAuB,CAAC1E,YAAD,CAAvB,CAAsCoE,QAAtC,EAAgDC,QAAhD,EAA0DC,QAA1D,CAAP;EACD,CAJD,MAIO;IACL,IAAIY,MAAM,GAAGd,QAAb;;IAEA,IAAIpE,YAAY,KAAKhB,sBAArB,EAA6C;MAC3CkG,MAAM,GAAGrG,gBAAgB,CAACuF,QAAD,CAAzB;IACD;;IAED,OAAOc,MAAP;EACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,eAAT,CAAyBrF,IAAzB,EAA+B8E,SAA/B,EAA0CQ,IAA1C,EAAgD;EACrD,IAAI,CAACtF,IAAL,EAAW;IACT;EACD;;EAED,IAAIE,YAAY,GAAGF,IAAI,CAACiF,QAAL,GAAgBvE,SAAhB,GAA4BR,YAA/C;;EAEA,IAAIA,YAAY,KAAKhB,sBAAjB,IAA2CgB,YAAY,KAAKf,yBAAhE,EAA2F;IACzF;EACD;;EAED,IAAImF,QAAQ,GAAGtE,IAAI,CAAC+E,cAAL,CAAoBD,SAApB,CAAf;;EAEA,IAAI5E,YAAY,KAAKhB,sBAAjB,IAA2C,CAACL,QAAQ,CAACyF,QAAD,CAAxD,EAAoE;IAClEA,QAAQ,GAAG,IAAX;EACD;;EAED,IAAIA,QAAJ,EAAc;IACZ,OAAOA,QAAQ,CAACgB,IAAD,CAAf;EACD;AACF"},"metadata":{},"sourceType":"module"}