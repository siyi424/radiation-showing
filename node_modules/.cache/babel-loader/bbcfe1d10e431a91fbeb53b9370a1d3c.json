{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine.js';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { CtorInt32Array } from '../DataStore.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper.js';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema.js';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\n\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\n\nexport default function prepareSeriesDataSchema( // TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be diplayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n\n    return resultList[idx];\n  }\n\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.\n\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  } // Set dim `name` and other `coordDim` and other props.\n\n\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.\n\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n\n        generateCoordCount--;\n      }\n\n      ifNoNameFillWithCoordName(resultItem);\n\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first colum should better be treated as a \"ordinal\" although it\n      // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    }); // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\n\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genCoordDimName(name, map, fromZero) {\n  var mapData = map.data;\n\n  if (fromZero || mapData.hasOwnProperty(name)) {\n    var i = 0;\n\n    while (mapData.hasOwnProperty(name + i)) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}","map":{"version":3,"names":["VISUAL_DIMENSIONS","SeriesDimensionDefine","createHashMap","defaults","each","extend","isObject","isString","createSourceFromSeriesDataOption","isSourceInstance","CtorInt32Array","normalizeToArray","BE_ORDINAL","guessOrdinal","createDimNameMap","ensureSourceDimNameMap","SeriesDataSchema","shouldOmitUnusedDimensions","createDimensions","source","opt","prepareSeriesDataSchema","dimensions","sysDims","coordDimensions","dimsDef","dimensionsDefine","coordDimNameMap","resultList","dimCount","getDimCount","dimensionsCount","omitUnusedDimensions","canOmitUnusedDimensions","isUsingSourceDimensionsDef","dataDimNameMap","encodeDef","encodeDefine","encodeDefaulter","encodeDefMap","indicesMap","i","length","getResultItem","dimIdx","idx","dimDefItemRaw","dimDefItem","name","resultItem","userDimName","get","displayName","type","newIdx","storeDimIndex","push","dataDimsRaw","coordDim","dataDims","slice","set","validDataDims","resultDimIdxOrName","resultDimIdx","applyDim","availDimIdx","sysDimItemRaw","sysDimItemDimsDef","sysDimItemOtherDims","sysDimItem","ordinalMeta","otherDims","coordDimIndex","sysDimItemDimsDefItem","defaultTooltip","generateCoord","generateCoordCount","fromZero","extra","ifNoNameFillWithCoordName","genCoordDimName","isExtraCoord","Must","itemName","seriesName","sort","item0","item1","removeDuplication","fullDimensionCount","dimensionOmitted","result","duplicationMap","dim","dimOriginalName","count","optDimCount","Math","max","dimensionsDetectedCount","map","mapData","data","hasOwnProperty"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/data/helper/createDimensions.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine.js';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { CtorInt32Array } from '../DataStore.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper.js';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema.js';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\n\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\n\nexport default function prepareSeriesDataSchema( // TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be diplayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n\n    return resultList[idx];\n  }\n\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.\n\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  } // Set dim `name` and other `coordDim` and other props.\n\n\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.\n\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n\n        generateCoordCount--;\n      }\n\n      ifNoNameFillWithCoordName(resultItem);\n\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first colum should better be treated as a \"ordinal\" although it\n      // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    }); // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\n\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genCoordDimName(name, map, fromZero) {\n  var mapData = map.data;\n\n  if (fromZero || mapData.hasOwnProperty(name)) {\n    var i = 0;\n\n    while (mapData.hasOwnProperty(name + i)) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}