{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, indexOf, curry, assert, map, createHashMap } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as brushHelper from './brushHelper.js';\nimport { parseFinder as modelUtilParseFinder } from '../../util/model.js'; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    each(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        each(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n        assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n      }\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return map(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: brushHelper.makeRectPanelClipPath(rect),\n        isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return modelUtilParseFinder(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = map(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n  }\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nexport default BrushTargetManager;","map":{"version":3,"names":["each","indexOf","curry","assert","map","createHashMap","graphic","brushHelper","parseFinder","modelUtilParseFinder","INCLUDE_FINDER_MAIN_TYPES","BrushTargetManager","finder","ecModel","opt","_this","_targetInfoList","foundCpts","targetInfoBuilders","builder","type","include","prototype","setOutputRanges","areas","matchOutputRanges","area","coordRange","coordSys","coordRanges","push","result","coordConvert","brushType","__rangeOffset","offset","diffProcessor","values","range","xyMinMax","cb","targetInfo","findTargetInfo","coordSyses","setInputRanges","process","env","NODE_ENV","panelId","rangeOffset","getScales","makePanelOpts","api","getDefaultBrushType","rect","getPanelRect","defaultBrushType","clipPath","makeRectPanelClipPath","isTargetByCursor","makeRectIsTargetByCursor","coordSysModel","getLinearBrushOtherExtent","makeLinearBrushOtherExtent","controlSeries","seriesModel","coordinateSystem","targetInfoList","i","length","areaPanelId","j","targetInfoMatchers","formatMinMax","minMax","reverse","includeMainTypes","grid","xAxisModels","yAxisModels","gridModels","gridModelMap","xAxesHas","yAxesHas","axisModel","gridModel","axis","model","set","id","cartesians","getCartesians","cartesian","index","getAxis","panelRectBuilders","xAxisDeclared","yAxisDeclared","geo","geoModels","geoModel","xAxisModel","yAxisModel","master","getRect","clone","getBoundingRect","applyTransform","getTransform","lineX","axisConvert","lineY","to","rangeOrCoordRange","clamp","xminymin","pointToData","dataToPoint","xmaxymax","polygon","Infinity","item","p","Math","min","max","axisNameIndex","coordToData","toLocalCoord","toGlobalCoord","dataToCoord","NaN","axisDiffProcessor","refer","scales","idx","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","isNaN"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/component/helper/BrushTargetManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, indexOf, curry, assert, map, createHashMap } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport * as brushHelper from './brushHelper.js';\nimport { parseFinder as modelUtilParseFinder } from '../../util/model.js'; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    each(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        each(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n        assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n      }\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return map(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: brushHelper.makeRectPanelClipPath(rect),\n        isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return modelUtilParseFinder(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = map(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n  }\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nexport default BrushTargetManager;"],"mappings":"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"},"metadata":{},"sourceType":"module"}