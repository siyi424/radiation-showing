{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;","map":{"version":3,"names":["dataIndexMapValueLength","valNumOrArrLengthMoreThan2","length","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","context","diffMode","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","prototype","add","func","_add","update","_update","updateManyToOne","_updateManyToOne","updateOneToMany","_updateOneToMany","updateManyToMany","_updateManyToMany","remove","_remove","execute","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","i","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","i_1","newKey","idxMapValLen","j","arr","map","keyArr","keyGetterName","cbModeMultiple","key","idxMapVal","push"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/data/DataDiffer.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;"],"mappings":"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"},"metadata":{},"sourceType":"module"}