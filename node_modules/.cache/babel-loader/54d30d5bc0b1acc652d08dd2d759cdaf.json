{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, extend, isNumber } from 'zrender/lib/core/util.js';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider.js';\nimport { parseDataValue } from './dataValueHelper.js';\nimport { log, makePrintable, throwError } from '../../util/log.js';\nimport { createSource, detectSourceFormat } from '../Source.js';\n/**\n * TODO: disable writable.\n * This structure will be exposed to users.\n */\n\nvar ExternalSource =\n/** @class */\nfunction () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\n   * @return If dimension not found, return null/undefined.\n   */\n\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\n   * dimensions defined if and only if either:\n   * (a) dataset.dimensions are declared.\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\n   * the defined dimensions.\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\n   * @return Always return an array (even empty array).\n   */\n\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\n   * Only support by dimension index.\n   * No need to support by dimension name in transform function,\n   * becuase transform function is not case-specific, no need to use name literally.\n   */\n\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexport { ExternalSource };\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n\n  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n    }\n\n    throwError(errMsg);\n  } // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Becuase the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is relialbe and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n\n\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt); // Users probably not sepcify dimension name. For simplicity, data transform\n      // do not generate dimension name.\n\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbid name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          throwError(errMsg_1);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      // Do not generete name or anything others. The consequence process in\n      // `transform` or `series` probably have there own name generation strategry.\n      dimensions.push({\n        index: i\n      });\n    }\n  } // Implement public methods:\n\n\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex]; // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  return upstream.data;\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  } // Keep the same logic as `List::getDimension` did.\n\n\n  if (isNumber(dim) // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\n\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    throwError(errMsg);\n  } // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i); // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    throwError(errMsg);\n  }\n\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    throwError(errMsg);\n  } // Prepare source\n\n\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log(printStrArr);\n    }\n  }\n\n  return map(resultList, function (result, resultIndex) {\n    var errMsg = '';\n\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      throwError(errMsg);\n    }\n\n    if (!result.data) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be not be null or undefined';\n      }\n\n      throwError(errMsg);\n    }\n\n    var sourceFormat = detectSourceFormat(result.data);\n\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be array rows or object rows.';\n      }\n\n      throwError(errMsg);\n    }\n\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\n     * Intuitively, the end users known the content of the original `dataset.source`,\n     * calucating the transform result in mind.\n     * Suppose the original `dataset.source` is:\n     * ```js\n     * [\n     *     ['product', '2012', '2013', '2014', '2015'],\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\n     * ]\n     * ```\n     * The dimension info have to be detected from the source data.\n     * Some of the transformers (like filter, sort) will follow the dimension info\n     * of upstream, while others use new dimensions (like aggregate).\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\n     * We also allow transformers to ignore the output `dimensions` field, and\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\n     * dimensions in transformers.\n     *\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n     */\n\n    if (firstUpSource && resultIndex === 0 // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex; // We copy the header of upstream to the result becuase:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n\n    return createSource(result.data, resultMetaRawOption, null);\n  });\n}\n\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;\n}","map":{"version":3,"names":["SERIES_LAYOUT_BY_COLUMN","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_ARRAY_ROWS","normalizeToArray","createHashMap","bind","each","hasOwn","map","clone","isObject","extend","isNumber","getRawSourceItemGetter","getRawSourceDataCounter","getRawSourceValueGetter","parseDataValue","log","makePrintable","throwError","createSource","detectSourceFormat","ExternalSource","prototype","getRawData","Error","getRawDataItem","dataIndex","cloneRawData","getDimensionInfo","dim","cloneAllDimensionInfo","count","retrieveValue","dimIndex","retrieveValueFromItem","dataItem","convertValue","rawVal","dimInfo","createExternalSource","internalSource","externalTransform","extSource","data","sourceFormat","sourceHeaderCount","startIndex","errMsg","seriesLayoutBy","process","env","NODE_ENV","dimensions","dimsByName","dimsDef","dimensionsDefine","dimDef","idx","name","dimDefExt","index","displayName","push","errMsg_1","i","dimensionsDetectedCount","rawItemGetter","__isBuiltIn","rawCounter","rawValueGetter","rawItem","upstream","isSupportedSourceFormat","result","len","length","slice","isNaN","externalTransformMap","registerExternalTransform","type","typeParsed","split","isBuiltIn","set","applyDataTransform","rawTransOption","sourceList","infoForPrint","pipedTransOption","pipeLen","transOption","applySingleDataTransform","Math","max","upSourceList","pipeIndex","transType","get","extUpSourceList","upSource","resultList","transform","upstreamList","config","print","printStrArr","pipeIndexStr","datasetIndex","join","resultIndex","resultMetaRawOption","firstUpSource","concat","sourceHeader","metaRawOption"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/data/helper/transform.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, extend, isNumber } from 'zrender/lib/core/util.js';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider.js';\nimport { parseDataValue } from './dataValueHelper.js';\nimport { log, makePrintable, throwError } from '../../util/log.js';\nimport { createSource, detectSourceFormat } from '../Source.js';\n/**\n * TODO: disable writable.\n * This structure will be exposed to users.\n */\n\nvar ExternalSource =\n/** @class */\nfunction () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\n   * @return If dimension not found, return null/undefined.\n   */\n\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\n   * dimensions defined if and only if either:\n   * (a) dataset.dimensions are declared.\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\n   * the defined dimensions.\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\n   * @return Always return an array (even empty array).\n   */\n\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\n   * Only support by dimension index.\n   * No need to support by dimension name in transform function,\n   * becuase transform function is not case-specific, no need to use name literally.\n   */\n\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexport { ExternalSource };\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n\n  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n    }\n\n    throwError(errMsg);\n  } // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Becuase the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is relialbe and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n\n\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt); // Users probably not sepcify dimension name. For simplicity, data transform\n      // do not generate dimension name.\n\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbid name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          throwError(errMsg_1);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n      for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n        // Do not generete name or anything others. The consequence process in\n        // `transform` or `series` probably have there own name generation strategry.\n        dimensions.push({\n          index: i\n        });\n      }\n    } // Implement public methods:\n\n\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex]; // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  return upstream.data;\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  } // Keep the same logic as `List::getDimension` did.\n\n\n  if (isNumber(dim) // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\n\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    throwError(errMsg);\n  } // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i); // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    throwError(errMsg);\n  }\n\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    throwError(errMsg);\n  } // Prepare source\n\n\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log(printStrArr);\n    }\n  }\n\n  return map(resultList, function (result, resultIndex) {\n    var errMsg = '';\n\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      throwError(errMsg);\n    }\n\n    if (!result.data) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be not be null or undefined';\n      }\n\n      throwError(errMsg);\n    }\n\n    var sourceFormat = detectSourceFormat(result.data);\n\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be array rows or object rows.';\n      }\n\n      throwError(errMsg);\n    }\n\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\n     * Intuitively, the end users known the content of the original `dataset.source`,\n     * calucating the transform result in mind.\n     * Suppose the original `dataset.source` is:\n     * ```js\n     * [\n     *     ['product', '2012', '2013', '2014', '2015'],\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\n     * ]\n     * ```\n     * The dimension info have to be detected from the source data.\n     * Some of the transformers (like filter, sort) will follow the dimension info\n     * of upstream, while others use new dimensions (like aggregate).\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\n     * We also allow transformers to ignore the output `dimensions` field, and\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\n     * dimensions in transformers.\n     *\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n     */\n\n    if (firstUpSource && resultIndex === 0 // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex; // We copy the header of upstream to the result becuase:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n\n    return createSource(result.data, resultMetaRawOption, null);\n  });\n}\n\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}