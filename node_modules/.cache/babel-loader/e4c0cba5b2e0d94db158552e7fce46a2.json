{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { Point, Path, Polyline } from '../util/graphic.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { normalizeRadian } from 'zrender/lib/contain/util.js';\nimport { cubicProjectPoint, quadraticProjectPoint } from 'zrender/lib/core/curve.js';\nimport { defaults, retrieve2 } from 'zrender/lib/core/util.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport { DISPLAY_STATES, SPECIAL_STATES } from '../util/states.js';\nvar PI2 = Math.PI * 2;\nvar CMD = PathProxy.CMD;\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\n\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n\n  switch (pos) {\n    case 'top':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n\n    case 'bottom':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n\n    case 'left':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n\n    case 'right':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\n\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d; // Intersect point.\n\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    // Project point is on the arc.\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\n\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen; // dot product\n\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nvar tmpPt = [];\n\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n/**\n * Calculate min distance corresponding point.\n * This method won't evaluate if point is in the path.\n */\n\n\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    var d = minDist;\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i <= 1) {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n\n  return minDist;\n} // Temporal varible for intermediate usage.\n\n\nvar pt0 = new Point();\nvar pt1 = new Point();\nvar pt2 = new Point();\nvar dir = new Point();\nvar dir2 = new Point();\n/**\n * Calculate a proper guide line based on the label position and graphic element definition\n * @param label\n * @param labelRect\n * @param target\n * @param targetRect\n */\n\nexport function updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent(); // Needs to create text guide in each charts.\n\n  if (!(label && labelLine)) {\n    return;\n  }\n\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && invert([], targetTransform);\n  var len = labelLineModel.get('length2') || 0;\n\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    Point.scaleAndAdd(pt1, pt0, dir, len); // Transform to target coord space.\n\n    pt1.transform(targetInversedTransform); // Note: getBoundingRect will ensure the `path` being created.\n\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2); // TODO pt2 is in the path\n\n    if (dist < minDist) {\n      minDist = dist; // Transform back to global space.\n\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n  labelLine.setShape({\n    points: points\n  });\n} // Temporal variable for the limitTurnAngle function\n\nvar tmpArr = [];\nvar tmpProjPoint = new Point();\n/**\n * Reduce the line segment attached to the label to limit the turn angle between two segments.\n * @param linePoints\n * @param minTurnAngle Radian of minimum turn angle. 0 - 180\n */\n\nexport function limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n\n  minTurnAngle = minTurnAngle / 180 * Math.PI; // The line points can be\n  //      /pt1----pt2 (label)\n  //     /\n  // pt0/\n\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt0, pt1);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n\n  if (minTurnAngleCos < angleCos) {\n    // Smaller than minTurnAngle\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr); // Calculate new projected length with limited minTurnAngle and get the new connect point\n\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n    if (isNaN(t)) {\n      return;\n    }\n\n    if (t < 0) {\n      Point.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      Point.copy(tmpProjPoint, pt2);\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n/**\n * Limit the angle of line and the surface\n * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite\n */\n\nexport function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt1, pt0);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n\n  if (angleCos < maxSurfaceAngleCos) {\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n\n    if (newAngle >= HALF_PI) {\n      // parallel\n      Point.copy(tmpProjPoint, pt2);\n    } else {\n      // Calculate new projected length with limited minTurnAngle and get the new connect point\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n      if (isNaN(t)) {\n        return;\n      }\n\n      if (t < 0) {\n        Point.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        Point.copy(tmpProjPoint, pt2);\n      }\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === 'normal';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName); // Make sure display.\n\n  stateObj.ignore = ignore; // Set smooth\n\n  var smooth = stateModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n\n  stateObj.shape = stateObj.shape || {};\n\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\n\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n\n  if (!points) {\n    return;\n  }\n\n  path.moveTo(points[0][0], points[0][1]);\n\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = vector.dist(points[0], points[1]);\n    var len2 = vector.dist(points[1], points[2]);\n\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n/**\n * Create a label line if necessary and set it's style.\n */\n\n\nexport function setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n\n  if (!label) {\n    // Not show label line if there is no label.\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n\n    return;\n  }\n\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get('show');\n  var labelIgnoreNormal = label.ignore;\n\n  for (var i = 0; i < DISPLAY_STATES.length; i++) {\n    var stateName = DISPLAY_STATES[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === 'normal';\n\n    if (stateModel) {\n      var stateShow = stateModel.get('show');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n\n      if (isLabelIgnored // Not show when label is not shown in this state.\n      || !retrieve2(stateShow, showNormal) // Use normal state by default if not set.\n      ) {\n        var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];\n\n        if (stateObj) {\n          stateObj.ignore = true;\n        }\n\n        continue;\n      } // Create labelLine if not exists\n\n\n      if (!labelLine) {\n        labelLine = new Polyline();\n        targetEl.setTextGuideLine(labelLine); // Reset state of normal because it's new created.\n        // NOTE: NORMAL should always been the first!\n\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n        } // Use same state proxy.\n\n\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n\n  if (labelLine) {\n    defaults(labelLine.style, defaultStyle); // Not fill.\n\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get('showAbove');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false; // Custom the buildPath.\n\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\nexport function getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || 'labelLine';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n\n  for (var i = 0; i < SPECIAL_STATES.length; i++) {\n    var stateName = SPECIAL_STATES[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n\n  return statesModels;\n}","map":{"version":3,"names":["Point","Path","Polyline","PathProxy","normalizeRadian","cubicProjectPoint","quadraticProjectPoint","defaults","retrieve2","invert","vector","DISPLAY_STATES","SPECIAL_STATES","PI2","Math","PI","CMD","DEFAULT_SEARCH_SPACE","getCandidateAnchor","pos","distance","rect","outPt","outDir","width","height","set","x","y","projectPointToArc","cx","cy","r","startAngle","endAngle","anticlockwise","out","d","sqrt","ox","oy","abs","tmp","angle","atan2","x1","cos","y1","sin","x2","y2","d1","d2","projectPointToLine","limitToEnds","dx","dy","dx1","dy1","lineLen","projectedLen","t","min","max","projectPointToRect","tmpPt","nearestPointOnRect","pt","dist","nearestPointOnPath","path","xi","yi","x0","y0","minDist","Infinity","data","i","length","cmd","M","L","C","Q","A","rx","ry","theta","dTheta","_x","R","Z","pt0","pt1","pt2","dir","dir2","updateLabelLinePoints","target","labelLineModel","labelLine","getTextGuideLine","label","getTextContent","labelGuideConfig","textGuideLineConfig","points","searchSpace","candidates","labelRect","getBoundingRect","clone","applyTransform","getComputedTransform","anchorPoint","anchor","targetTransform","targetInversedTransform","len","get","copy","candidate","scaleAndAdd","transform","boundingRect","toArray","limitTurnAngle","setShape","tmpArr","tmpProjPoint","linePoints","minTurnAngle","fromArray","sub","len1","len2","scale","angleCos","dot","minTurnAngleCos","tan","isNaN","limitSurfaceAngle","surfaceNormal","maxSurfaceAngle","maxSurfaceAngleCos","HALF_PI","angle2","acos","newAngle","setLabelLineState","ignore","stateName","stateModel","isNormal","stateObj","ensureState","smooth","shape","styleObj","getModel","getLineStyle","useStyle","style","buildLabelLinePath","moveTo","lineTo","moveLen","midPoint0","lerp","midPoint2","midPoint1","bezierCurveTo","setLabelLineStyle","targetEl","statesModels","defaultStyle","removeTextGuideLine","normalModel","normal","showNormal","labelIgnoreNormal","stateShow","isLabelIgnored","states","setTextGuideLine","stateProxy","fill","showAbove","labelLineConfig","buildPath","getLabelLineStatesModels","itemModel","labelLineName"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/label/labelGuideHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { Point, Path, Polyline } from '../util/graphic.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { normalizeRadian } from 'zrender/lib/contain/util.js';\nimport { cubicProjectPoint, quadraticProjectPoint } from 'zrender/lib/core/curve.js';\nimport { defaults, retrieve2 } from 'zrender/lib/core/util.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport { DISPLAY_STATES, SPECIAL_STATES } from '../util/states.js';\nvar PI2 = Math.PI * 2;\nvar CMD = PathProxy.CMD;\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\n\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n\n  switch (pos) {\n    case 'top':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n\n    case 'bottom':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n\n    case 'left':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n\n    case 'right':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\n\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d; // Intersect point.\n\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    // Project point is on the arc.\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\n\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen; // dot product\n\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nvar tmpPt = [];\n\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n/**\n * Calculate min distance corresponding point.\n * This method won't evaluate if point is in the path.\n */\n\n\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    var d = minDist;\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i <= 1) {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n\n  return minDist;\n} // Temporal varible for intermediate usage.\n\n\nvar pt0 = new Point();\nvar pt1 = new Point();\nvar pt2 = new Point();\nvar dir = new Point();\nvar dir2 = new Point();\n/**\n * Calculate a proper guide line based on the label position and graphic element definition\n * @param label\n * @param labelRect\n * @param target\n * @param targetRect\n */\n\nexport function updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent(); // Needs to create text guide in each charts.\n\n  if (!(label && labelLine)) {\n    return;\n  }\n\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && invert([], targetTransform);\n  var len = labelLineModel.get('length2') || 0;\n\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    Point.scaleAndAdd(pt1, pt0, dir, len); // Transform to target coord space.\n\n    pt1.transform(targetInversedTransform); // Note: getBoundingRect will ensure the `path` being created.\n\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2); // TODO pt2 is in the path\n\n    if (dist < minDist) {\n      minDist = dist; // Transform back to global space.\n\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n  labelLine.setShape({\n    points: points\n  });\n} // Temporal variable for the limitTurnAngle function\n\nvar tmpArr = [];\nvar tmpProjPoint = new Point();\n/**\n * Reduce the line segment attached to the label to limit the turn angle between two segments.\n * @param linePoints\n * @param minTurnAngle Radian of minimum turn angle. 0 - 180\n */\n\nexport function limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n\n  minTurnAngle = minTurnAngle / 180 * Math.PI; // The line points can be\n  //      /pt1----pt2 (label)\n  //     /\n  // pt0/\n\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt0, pt1);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n\n  if (minTurnAngleCos < angleCos) {\n    // Smaller than minTurnAngle\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr); // Calculate new projected length with limited minTurnAngle and get the new connect point\n\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n    if (isNaN(t)) {\n      return;\n    }\n\n    if (t < 0) {\n      Point.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      Point.copy(tmpProjPoint, pt2);\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n/**\n * Limit the angle of line and the surface\n * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite\n */\n\nexport function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt1, pt0);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n\n  if (angleCos < maxSurfaceAngleCos) {\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n\n    if (newAngle >= HALF_PI) {\n      // parallel\n      Point.copy(tmpProjPoint, pt2);\n    } else {\n      // Calculate new projected length with limited minTurnAngle and get the new connect point\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle)); // Limit the new calculated connect point between pt1 and pt2.\n\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n      if (isNaN(t)) {\n        return;\n      }\n\n      if (t < 0) {\n        Point.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        Point.copy(tmpProjPoint, pt2);\n      }\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === 'normal';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName); // Make sure display.\n\n  stateObj.ignore = ignore; // Set smooth\n\n  var smooth = stateModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n\n  stateObj.shape = stateObj.shape || {};\n\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\n\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n\n  if (!points) {\n    return;\n  }\n\n  path.moveTo(points[0][0], points[0][1]);\n\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = vector.dist(points[0], points[1]);\n    var len2 = vector.dist(points[1], points[2]);\n\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n/**\n * Create a label line if necessary and set it's style.\n */\n\n\nexport function setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n\n  if (!label) {\n    // Not show label line if there is no label.\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n\n    return;\n  }\n\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get('show');\n  var labelIgnoreNormal = label.ignore;\n\n  for (var i = 0; i < DISPLAY_STATES.length; i++) {\n    var stateName = DISPLAY_STATES[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === 'normal';\n\n    if (stateModel) {\n      var stateShow = stateModel.get('show');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n\n      if (isLabelIgnored // Not show when label is not shown in this state.\n      || !retrieve2(stateShow, showNormal) // Use normal state by default if not set.\n      ) {\n          var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];\n\n          if (stateObj) {\n            stateObj.ignore = true;\n          }\n\n          continue;\n        } // Create labelLine if not exists\n\n\n      if (!labelLine) {\n        labelLine = new Polyline();\n        targetEl.setTextGuideLine(labelLine); // Reset state of normal because it's new created.\n        // NOTE: NORMAL should always been the first!\n\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n        } // Use same state proxy.\n\n\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n\n  if (labelLine) {\n    defaults(labelLine.style, defaultStyle); // Not fill.\n\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get('showAbove');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false; // Custom the buildPath.\n\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\nexport function getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || 'labelLine';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n\n  for (var i = 0; i < SPECIAL_STATES.length; i++) {\n    var stateName = SPECIAL_STATES[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n\n  return statesModels;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}