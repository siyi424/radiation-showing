{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, map, isFunction, createHashMap, noop, assert } from 'zrender/lib/core/util.js';\nimport { createTask } from './task.js';\nimport { getUID } from '../util/component.js';\nimport GlobalModel from '../model/Global.js';\nimport ExtensionAPI from './ExtensionAPI.js';\nimport { normalizeToArray } from '../util/model.js';\n;\n\nvar Scheduler =\n/** @class */\nfunction () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    // key: handlerUID\n    this._stageTaskMap = createHashMap();\n    this.ecInstance = ecInstance;\n    this.api = api; // Fix current processors in case that in some rear cases that\n    // processors might be registered after echarts instance created.\n    // Register processors incrementally for a echarts instance is\n    // not supported by this stream architecture.\n\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    // TODO: Only restore needed series and components, but not all components.\n    // Currently `restoreData` of all of the series and component will be called.\n    // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n    // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n    // and some components like coordinate system, axes, dataZoom, visualMap only\n    // need their target series refresh.\n    // (1) If we are implementing this feature some day, we should consider these cases:\n    // if a data processor depends on a component (e.g., dataZoomProcessor depends\n    // on the settings of `dataZoom`), it should be re-performed if the component\n    // is modified by `setOption`.\n    // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n    // it should be re-performed when the result array of `getTargetSeries` changed.\n    // We use `dependencies` to cover these issues.\n    // (3) How to update target series when coordinate system related components modified.\n    // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n    // and this case all of the tasks will be set as dirty.\n    ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n    // depends on all of the series.\n    // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n    // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n    // that the overall task is set as dirty and to be performed, otherwise it probably cause\n    // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n    // probably cause state chaos (consider `dataZoomProcessor`).\n\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  }; // If seriesModel provided, incremental threshold is check by series data.\n\n\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    // For overall task\n    if (!task.__pipeline) {\n      return;\n    }\n\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n  /**\n   * Current, progressive rendering starts from visual and layout.\n   * Always detect render mode in the same stage, avoiding that incorrect\n   * detection caused by data filtering.\n   * Caution:\n   * `updateStreamModes` use `seriesModel.getData()`.\n   */\n\n\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n    var data = seriesModel.getData();\n    var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n    // animation frame. Note that some types of series do not provide\n    // `view.incrementalPrepareRender` but support `chart.appendData`. We\n    // use the term `incremental` but not `progressive` to describe the\n    // case that `chart.appendData`.\n\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n    // see `test/candlestick-large3.html`\n\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    each(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Currently do not need to support to sepecify them both.\n        errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n      }\n\n      assert(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n\n    this._pipe(model, renderTask);\n  };\n\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    // If we do not use `block` here, it should be considered when to update modes.\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    each(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n        // then execute the overall task. And stub will call seriesModel.setData,\n        // which ensures that in the overallTask seriesModel.getData() will not\n        // return incorrect data.\n\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n\n          var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n          // if intending to decalare `performRawSeries` in handlers, only\n          // stream-independent (specifically, data item independent) operations can be\n          // performed. Because is a series is filtered, most of the tasks will not\n          // be performed. A stream-dependent operation probably cause wrong biz logic.\n          // Perhaps we should not provide a separate callback for this case instead\n          // of providing the config `performRawSeries`. The stream-dependent operaions\n          // and stream-independent operations should better not be mixed.\n\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      // Progress to the end for dataInit and dataRestore.\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.plan = function () {\n    // Travel pipelines, check block.\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap; // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n    // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n    // it works but it may cause other irrelevant charts blocked.\n\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n      // Reuse original task instance.\n\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        // PENDING: `useClearVisual` not used?\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n    || createTask({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap; // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n\n    var newAgentStubMap = overallTask.agentStubMap = createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false; // FIXME:TS never used, so comment it\n    // let modifyOutputEnd = stageHandler.modifyOutputEnd;\n    // An overall task with seriesType detected or has `getTargetSeries`, we add\n    // stub in each pipelines, it will set the overall task dirty when the pipeline\n    // progress. Moreover, to avoid call the overall task each frame (too frequent),\n    // we set the pipeline block.\n\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n    }\n\n    assert(!stageHandler.createOnAllSeries, errMsg);\n\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    } // Otherwise, (usually it is legancy case), the overall task will only be\n    // executed when upstream dirty. Otherwise the progressive rendering of all\n    // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n    // dirty info from upsteam.\n    else {\n      overallProgress = false;\n      each(ecModel.getSeries(), createStub);\n    }\n\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || ( // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n      shouldOverallTaskDirty = true, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress // FIXME:TS never used, so comment it\n        // modifyOutputEnd: modifyOutputEnd\n\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n\n      scheduler._pipe(seriesModel, stub);\n    }\n\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n\n    var pipeline = this._pipelineMap.get(pipelineId);\n\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if (isFunction(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n\n    stageHandler.uid = getUID('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n\n  ;\n  return Scheduler;\n}();\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name_1 in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name_1] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nexport default Scheduler;","map":{"version":3,"names":["each","map","isFunction","createHashMap","noop","assert","createTask","getUID","GlobalModel","ExtensionAPI","normalizeToArray","Scheduler","ecInstance","api","dataProcessorHandlers","visualHandlers","_stageTaskMap","_dataProcessorHandlers","slice","_visualHandlers","_allHandlers","concat","prototype","restoreData","ecModel","payload","taskRecord","overallTask","dirty","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","incremental","progressiveEnabled","progressiveRender","__idxInPipeline","blockIndex","step","modDataCount","modBy","Math","ceil","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","data","getData","dataLen","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","round","_pipe","dataTask","prepareStageTasks","stageTaskMap","getModel","handler","record","errMsg","process","env","NODE_ENV","reset","overallReset","_createSeriesStageTask","_createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","_performStageTasks","block","performVisualTasks","opt","stageHandlers","unfinished","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallNeedDirty_1","agentStubMap","stub","needSetDirty","updatePayload","performArgs_1","perform","performArgs","skip","performRawSeries","isSeriesFiltered","setDirty","dirtyMap","performSeriesTasks","plan","getUpstream","oldSeriesTaskMap","newSeriesTaskMap","seriesType","getTargetSeries","createOnAllSeries","eachRawSeries","create","eachRawSeriesByType","seriesTaskPlan","seriesTaskReset","seriesTaskCount","useClearVisual","isVisual","isLayout","overallTaskReset","oldAgentStubMap","newAgentStubMap","overallProgress","shouldOverallTaskDirty","createStub","getSeries","stubReset","onDirty","stubOnDirty","agent","pipe","wrapStageHandler","detectSeriseType","stubProgress","getDownstream","clearAllVisual","resetDefines","length","v","makeSeriesTaskProgress","singleSeriesTaskProgress","resetDefineIdx","params","resetDefine","dataEach","i","start","end","progress","legacyFunc","ecModelMock","apiMock","e","mockMethods","eachSeriesByType","type","eachComponent","cond","mainType","subType","target","Clz","name_1"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/core/Scheduler.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, map, isFunction, createHashMap, noop, assert } from 'zrender/lib/core/util.js';\nimport { createTask } from './task.js';\nimport { getUID } from '../util/component.js';\nimport GlobalModel from '../model/Global.js';\nimport ExtensionAPI from './ExtensionAPI.js';\nimport { normalizeToArray } from '../util/model.js';\n;\n\nvar Scheduler =\n/** @class */\nfunction () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    // key: handlerUID\n    this._stageTaskMap = createHashMap();\n    this.ecInstance = ecInstance;\n    this.api = api; // Fix current processors in case that in some rear cases that\n    // processors might be registered after echarts instance created.\n    // Register processors incrementally for a echarts instance is\n    // not supported by this stream architecture.\n\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    // TODO: Only restore needed series and components, but not all components.\n    // Currently `restoreData` of all of the series and component will be called.\n    // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n    // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n    // and some components like coordinate system, axes, dataZoom, visualMap only\n    // need their target series refresh.\n    // (1) If we are implementing this feature some day, we should consider these cases:\n    // if a data processor depends on a component (e.g., dataZoomProcessor depends\n    // on the settings of `dataZoom`), it should be re-performed if the component\n    // is modified by `setOption`.\n    // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n    // it should be re-performed when the result array of `getTargetSeries` changed.\n    // We use `dependencies` to cover these issues.\n    // (3) How to update target series when coordinate system related components modified.\n    // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n    // and this case all of the tasks will be set as dirty.\n    ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n    // depends on all of the series.\n    // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n    // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n    // that the overall task is set as dirty and to be performed, otherwise it probably cause\n    // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n    // probably cause state chaos (consider `dataZoomProcessor`).\n\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  }; // If seriesModel provided, incremental threshold is check by series data.\n\n\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    // For overall task\n    if (!task.__pipeline) {\n      return;\n    }\n\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n  /**\n   * Current, progressive rendering starts from visual and layout.\n   * Always detect render mode in the same stage, avoiding that incorrect\n   * detection caused by data filtering.\n   * Caution:\n   * `updateStreamModes` use `seriesModel.getData()`.\n   */\n\n\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n    var data = seriesModel.getData();\n    var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n    // animation frame. Note that some types of series do not provide\n    // `view.incrementalPrepareRender` but support `chart.appendData`. We\n    // use the term `incremental` but not `progressive` to describe the\n    // case that `chart.appendData`.\n\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n    // see `test/candlestick-large3.html`\n\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    each(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Currently do not need to support to sepecify them both.\n        errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n      }\n\n      assert(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n\n    this._pipe(model, renderTask);\n  };\n\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    // If we do not use `block` here, it should be considered when to update modes.\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    each(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n        // then execute the overall task. And stub will call seriesModel.setData,\n        // which ensures that in the overallTask seriesModel.getData() will not\n        // return incorrect data.\n\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n\n          var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n          // if intending to decalare `performRawSeries` in handlers, only\n          // stream-independent (specifically, data item independent) operations can be\n          // performed. Because is a series is filtered, most of the tasks will not\n          // be performed. A stream-dependent operation probably cause wrong biz logic.\n          // Perhaps we should not provide a separate callback for this case instead\n          // of providing the config `performRawSeries`. The stream-dependent operaions\n          // and stream-independent operations should better not be mixed.\n\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      // Progress to the end for dataInit and dataRestore.\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.plan = function () {\n    // Travel pipelines, check block.\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap; // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n    // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n    // it works but it may cause other irrelevant charts blocked.\n\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n      // Reuse original task instance.\n\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        // PENDING: `useClearVisual` not used?\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n    || createTask({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap; // The count of stages are totally about only several dozen, so\n    // do not need to reuse the map.\n\n    var newAgentStubMap = overallTask.agentStubMap = createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false; // FIXME:TS never used, so comment it\n    // let modifyOutputEnd = stageHandler.modifyOutputEnd;\n    // An overall task with seriesType detected or has `getTargetSeries`, we add\n    // stub in each pipelines, it will set the overall task dirty when the pipeline\n    // progress. Moreover, to avoid call the overall task each frame (too frequent),\n    // we set the pipeline block.\n\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n    }\n\n    assert(!stageHandler.createOnAllSeries, errMsg);\n\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    } // Otherwise, (usually it is legancy case), the overall task will only be\n    // executed when upstream dirty. Otherwise the progressive rendering of all\n    // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n    // dirty info from upsteam.\n    else {\n        overallProgress = false;\n        each(ecModel.getSeries(), createStub);\n      }\n\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || ( // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n      shouldOverallTaskDirty = true, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress // FIXME:TS never used, so comment it\n        // modifyOutputEnd: modifyOutputEnd\n\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n\n      scheduler._pipe(seriesModel, stub);\n    }\n\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n\n    var pipeline = this._pipelineMap.get(pipelineId);\n\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if (isFunction(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n\n    stageHandler.uid = getUID('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n\n  ;\n  return Scheduler;\n}();\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name_1 in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name_1] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nexport default Scheduler;"],"mappings":"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"},"metadata":{},"sourceType":"module"}