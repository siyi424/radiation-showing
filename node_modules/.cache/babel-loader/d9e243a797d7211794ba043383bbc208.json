{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { BoundingRect, OrientedBoundingRect } from '../util/graphic.js';\nexport function prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform(); // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.\n\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  } // TODO bleedMargin?\n\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap(); // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1); // Handle bailout when there is not enough space.\n\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  } // Squeeze gaps if the labels exceed margin.\n\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent; // Forward\n\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\n   * Squeeze to allow overlap if there is no more space available.\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\n   */\n\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n/**\n * Adjust labels on x direction to avoid overlap.\n */\n\n\nexport function shiftLayoutOnX(list, leftBound, rightBound, // If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n/**\n * Adjust labels on y direction to avoid overlap.\n */\n\nexport function shiftLayoutOnY(list, topBound, bottomBound, // If average the shifts on all labels and add them to 0\nbalanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\nexport function hideOverlap(labelList) {\n  var displayedLabels = []; // TODO, render overflow visible first, put in the displayedLabels.\n\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect); // Add a threshold because layout may be aligned precisely.\n\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j]; // Fast rejection.\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        // Is overlapped\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        // If self is not axis aligned. But other is.\n        existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        // If self is axis aligned. But other is not.\n        obb = new OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    } // TODO Callback to determine if this overlap should be handled?\n\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}","map":{"version":3,"names":["BoundingRect","OrientedBoundingRect","prepareLayoutList","input","list","i","length","rawItem","defaultAttr","ignore","label","transform","getComputedTransform","localRect","getBoundingRect","isAxisAligned","minMargin","style","margin","globalRect","clone","applyTransform","x","y","width","height","obb","push","labelLine","rect","priority","layoutOption","computedLayoutOption","axisAligned","shiftLayout","xyDim","sizeDim","minBound","maxBound","balanceShift","len","sort","a","b","lastPos","delta","adjusted","shifts","totalShifts","item","shift","Math","max","shiftList","first","last","minGap","maxGap","updateMinMaxGap","squeezeGaps","takeBoundsGap","squeezeWhenBailout","gapThisBound","gapOtherBound","moveDir","moveFromMaxGap","min","remained","start","end","maxSqeezePercent","gaps","totalGaps","prevItemRect","gap","squeezePercent","abs","movement","dir","moveForEachLabel","ceil","shiftLayoutOnX","leftBound","rightBound","shiftLayoutOnY","topBound","bottomBound","hideOverlap","labelList","displayedLabels","hideEl","el","emphasisState","ensureState","labelItem","copy","overlapped","j","existsTextCfg","intersect","attr","labelGuideIgnore"],"sources":["/home/siyi/Projects/radi-demo/radi-showing/node_modules/echarts/lib/label/labelLayoutHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { BoundingRect, OrientedBoundingRect } from '../util/graphic.js';\nexport function prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform(); // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.\n\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  } // TODO bleedMargin?\n\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap(); // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1); // Handle bailout when there is not enough space.\n\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  } // Squeeze gaps if the labels exceed margin.\n\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent; // Forward\n\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\n   * Squeeze to allow overlap if there is no more space available.\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\n   */\n\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n/**\n * Adjust labels on x direction to avoid overlap.\n */\n\n\nexport function shiftLayoutOnX(list, leftBound, rightBound, // If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n/**\n * Adjust labels on y direction to avoid overlap.\n */\n\nexport function shiftLayoutOnY(list, topBound, bottomBound, // If average the shifts on all labels and add them to 0\nbalanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\nexport function hideOverlap(labelList) {\n  var displayedLabels = []; // TODO, render overflow visible first, put in the displayedLabels.\n\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect); // Add a threshold because layout may be aligned precisely.\n\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j]; // Fast rejection.\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        // Is overlapped\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        // If self is not axis aligned. But other is.\n        existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        // If self is axis aligned. But other is not.\n        obb = new OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    } // TODO Callback to determine if this overlap should be handled?\n\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}